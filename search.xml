<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot2—容器功能之组件添加</title>
      <link href="/2021/10/02/SpringBoot2%E2%80%94%E5%AE%B9%E5%99%A8%E5%8A%9F%E8%83%BD%E4%B9%8B%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0/"/>
      <url>/2021/10/02/SpringBoot2%E2%80%94%E5%AE%B9%E5%99%A8%E5%8A%9F%E8%83%BD%E4%B9%8B%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<p>这里讲述了SpringBoot的容器功能的组件添加，包括「配置类、Full模式与Lite模式、条件装配与测试类」</p><span id="more"></span><h2 id="配置类概述-Configuration"><a href="#配置类概述-Configuration" class="headerlink" title="配置类概述(@Configuration)"></a>配置类概述(@Configuration)</h2><p><code>@Configuration</code>写在类上，用于标记这是“配置类”。配置类方法中用<code>@Bean</code>注册组件，<strong>配置类本身也是组件</strong>。<br>PS：配置类相当于曾经的配置文件</p><h2 id="Full模式与Lite模式"><a href="#Full模式与Lite模式" class="headerlink" title="Full模式与Lite模式"></a>Full模式与Lite模式</h2><p>该标签可以有参数<code>@Configuration(proxyBeanMethods = true/false)</code>用于控制是否为“代理组件方法”。二者区别</p><ul><li>Lite模式：<br>【保证每个@Bean方法被调用多少次返回的组件都是单实例的】，用于【配置类组件之间无依赖关系】</li><li>Full模式：<br>【每个@Bean方法被调用多少次返回的组件都是新创建的】用于【配置类组件之间有依赖关系】<h2 id="组件注册-Bean"><a href="#组件注册-Bean" class="headerlink" title="组件注册(@Bean)"></a>组件注册(@Bean)</h2>配置类里面使用@Bean标注在方法上给容器注册组件，默认是单实例的。</li></ul><p>注册时，默认以<strong>方法名 = 组件id</strong>，<strong>返回类型 = 组件类型</strong>，<strong>返回的值 = 组件在容器中的实例</strong><br><strong>自定义组件名</strong>：如果在<code>@Bean(&quot;name&quot;)</code>则组件名(组件ID)就设定为name</p><p>配置类示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*已经有了User类和Pet类，位于`com.xxx.xxx.boot.bean`包下*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//配置类 lite模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件：lite模式下，这是一个全新的组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom&quot;)</span><span class="comment">//定义组件名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件注册-Import"><a href="#组件注册-Import" class="headerlink" title="组件注册(@Import)"></a>组件注册(@Import)</h2><p><code>@Configuration</code>使用<code>@Import(&#123;构造器, 构造器&#125;)</code>的方式也可以注册对应类型的组件，此时组件名为“<strong>全类名</strong>”<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*写在类之前*/</span></span><br><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="条件装配-Conditional"><a href="#条件装配-Conditional" class="headerlink" title="条件装配(@Conditional)"></a>条件装配(@Conditional)</h2><p>这个注解的意思是，只有满足给定条件，对应代码才生效。十分常用的功能。<br>打开<code>@Conditional</code>的依赖树，看以看到很多子注解<br><img src="01.png" alt="各种条件装配"></p><p>下面以<code>@ConditionalOnBean</code>为例展示用法(示例上上一个大体相同，只是加了注解和**@Import**):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*已经有了User类和Pet类，位于`com.xxx.xxx.boot.bean`包下*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//配置类 lite模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnBean(name = &quot;com.atguigu.boot.bean.User&quot;)</span></span><br><span class="line"><span class="comment">// 条件装配注解，如果容器有name=com.atguigu.boot.bean.User的组件这个user01 组件才注册代码才生效</span></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件：lite模式下，这是一个全新的组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom&quot;)</span><span class="comment">//定义组件名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试类的写法"><a href="#测试类的写法" class="headerlink" title="测试类的写法"></a>测试类的写法</h2><p>在主函数写测试类，对应上述示例。测试类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、返回IOC容器</span></span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">//2、遍历容器里的组件</span></span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">//3、从容器中获取组件 getBean(组件名, 类型)</span></span><br><span class="line">        Pet tom1 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line">        Pet tom2 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"><span class="comment">//这里判断了在 full 和 lite 下，组件是非时同一个</span></span><br><span class="line">        System.out.println(<span class="string">&quot;组件&quot;</span> + (tom1 == tom2));</span><br><span class="line"><span class="comment">//这里证明了 “Configuration也是一个组件”</span></span><br><span class="line">System.out.println(run.getBean(MyConfig.class));</span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">//4、从容器中获取组件名 getBeanNamesForType(类型)</span></span><br><span class="line">        String[] beanNamesForType = run.getBeanNamesForType(User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;=========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : beanNamesForType) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">//5、组件存在判断（条件装配） containsBean(&quot;name&quot;)</span></span><br><span class="line">        <span class="keyword">boolean</span> tom = run.containsBean(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;tom:&quot;</span>+tom);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> user01 = run.containsBean(<span class="string">&quot;user01&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user01:&quot;</span>+user01);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> tom22 = run.containsBean(<span class="string">&quot;tom22&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;tom22:&quot;</span> + tom22);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中使用的方法：<br>|                            方法名                            |                   说明                   |<br>| :———————————————————-: | :————————————–: |<br>| ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); |         【标准写法】返回IOC容器          |<br>|            String[] run.getBeanDefinitionNames()             |     返回容器中所有组件名的String数组     |<br>|         String[] run.getBeanNamesForType(xxx.class)          | 返回容器所有“给定类型”的组件名String数组 |<br>|                类型 run.getBean(组件名, 类型)                |        返回对应组件名与类型的组件        |<br>|              boolean run.containsBean(“组件名”)              |      返回容器是否存在对应名字的组件      |</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置类 </tag>
            
            <tag> 条件装配 </tag>
            
            <tag> Bean组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2—依赖管理、starter导入与包结构</title>
      <link href="/2021/10/02/SpringBoot2%E2%80%94%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E3%80%81starter%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%8C%85%E7%BB%93%E6%9E%84/"/>
      <url>/2021/10/02/SpringBoot2%E2%80%94%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E3%80%81starter%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%8C%85%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>本文简单说明SpringBoot中的<strong>依赖管理</strong>、<strong>starter</strong>的作用与导入、<strong>包结构与扫描路径</strong>。其中讲述了复合注解<code>@SpringBootApplication</code>的展开</p><span id="more"></span><h2 id="1-依赖管理与starter导入"><a href="#1-依赖管理与starter导入" class="headerlink" title="1.依赖管理与starter导入"></a>1.依赖管理与starter导入</h2><h3 id="父项目依赖管理"><a href="#父项目依赖管理" class="headerlink" title="父项目依赖管理"></a>父项目依赖管理</h3><p>Spring Boot 使用 pom.xml 中的<strong>父项目做依赖(dependencies)管理</strong> (即：版本控制)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>跟进 pom.xml 中的<code>spring-boot-starter-parent</code>，会看到这个父项目还有一个父项目<code>spring-boot-dependencies</code>。跟进这个项目，可以看到各个常用依赖的具体版本，和依赖本身。<br>这个机制叫做——自动版本仲裁</p><h3 id="starter场景启动器"><a href="#starter场景启动器" class="headerlink" title="starter场景启动器"></a>starter场景启动器</h3><p>Starters 是一组方便的依赖描述符，只要导入starters就可以自动导入这个场景下所需的依赖项。<br>命名方式上，官方srarter(场景启动器)使用<code>spring-boot-starter-*</code>格式命名，第三方starter使用<code>*-spring-boot-starter</code>格式命名。这里的<code>*</code>就代表一种场景。<br>我们可以在<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">官方文档</a>查询所有的官方starter 。<br>所有场景启动器最底层的依赖是<code>spring-boot-starter-parent</code></p><h3 id="导入starter"><a href="#导入starter" class="headerlink" title="导入starter"></a>导入starter</h3><p>如果你要导入一个场景的依赖，那么就可以在文档中找到这个场景的starter。然后写入到 pom.xml 的<code>&lt;dependencies&gt;</code>标签。<br>你也可以找到对应场景启动器在<code>spring-boot-dependencies</code>中的<code>&lt;dependency&gt;</code>标签。复制<code>&lt;dependency&gt;</code>标签内容并粘贴在 pom.xml 。<br>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖库的版本"><a href="#依赖库的版本" class="headerlink" title="依赖库的版本"></a>依赖库的版本</h3><p>导入starter时，这些依赖的版本有两种控制方法——<strong>自动版本仲裁</strong>和<strong>手动指定</strong></p><ol><li><strong>自动版本仲裁</strong>：如果导入starter时没有设定<code>&lt;version&gt;</code>标签则会依据通过父项目依赖来指定版本</li><li><strong>手动指定版本</strong>：<br>查看<code>spring-boot-dependencies</code>里设定版本用的标签；<br>在 pom.xml 中手动添加一个<code>&lt;properties&gt;</code>标签，在内部重写配置；<br>可以使用的版本号在<a href="https://mvnrepository.com/">MVNrepository</a>中查找；</li></ol><p>手动版本指定示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外：还可以在导入starter时，添加<code>&lt;version&gt;</code>标签来实现。</p><h2 id="2-自动配置与包结构"><a href="#2-自动配置与包结构" class="headerlink" title="2.自动配置与包结构"></a>2.自动配置与包结构</h2><p>这里简单记录SpringBoot为我们配置的项目以及包结构与扫描路径</p><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><ul><li>自动配好Tomcat<ul><li>引入Tomcat依赖</li><li>配置Tomcat</li></ul></li><li>自动配好SpringMVC<ul><li>引入SpringMVC全套组件</li><li>自动配好SpringMVC常用组件（功能）</li></ul></li><li>自动配好Web常见功能，如：字符编码问题<ul><li>SpringBoot帮我们配置好了所有web开发的常见场景</li></ul></li><li>各种配置拥有默认值<ul><li> 默认配置最终都是映射到某个类上，如：MultipartProperties</li><li> 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li></ul></li><li>按需加载所有自动配置项<ul><li>非常多的starter</li><li>引入了哪些场景这个场景的自动配置才会开启</li><li>SpringBoot所有的自动配置功能都在 <code>spring-boot-autoconfigure</code> 包里面</li></ul></li><li>自定配置包扫描</li></ul><h2 id="3-包结构与扫描路径"><a href="#3-包结构与扫描路径" class="headerlink" title="3.包结构与扫描路径"></a>3.包结构与扫描路径</h2><p>得益于Spring Boot的自动配置，我们也无需进行包扫描配置</p><ul><li>默认扫描：主程序所在包及其所有子包里的组件</li><li>改变扫描路径：<ul><li>法一：<code>@SpringBootApplication(scanBasePackages=&quot;扫描起始包名&quot;)</code></li><li>法二：<code>@ComponentScan</code>指定扫描路径（看代码块说明）</li></ul></li><li>正常情况需要把业务<code>@RestController</code>放在主程序包的子包里</li></ul><p><code>@ComponentScan</code>说明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">是一个复合注解，等同于</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(&quot;com.atguigu.boot&quot;)</span><br><span class="line">所谓的“法二”就是把这个复合注解展开写，然后改一下第三个标签</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Starter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2—HelloWord</title>
      <link href="/2021/10/02/SpringBoot2%E2%80%94HelloWord/"/>
      <url>/2021/10/02/SpringBoot2%E2%80%94HelloWord/</url>
      
        <content type="html"><![CDATA[<p>这是SpringBoot2的第一篇文章，以HelloWorld程序为例，讲述了SpringBoot2基本的Maven项目创建方式，以及常用注解的使用。</p><span id="more"></span><h2 id="创建Maven项目"><a href="#创建Maven项目" class="headerlink" title="创建Maven项目"></a>创建Maven项目</h2><p>正常的使用IDEA创建一个Maven项目即可。</p><h2 id="配置依赖-pom-xml"><a href="#配置依赖-pom-xml" class="headerlink" title="配置依赖(pom.xml)"></a>配置依赖(pom.xml)</h2><p>这里需要配置SpringBoot依赖，一定要添加父项目做依赖管理：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为这次的HelloWorld实例需求是一个web应用场景，所以需要引入<code>spring-boot-starter-web</code>这一官方启动器。<br>※关于启动器的详细内容请看「SpringBoot2——依赖管理、starter导入与包结构」</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建主程序-SpringBootApplication"><a href="#创建主程序-SpringBootApplication" class="headerlink" title="创建主程序(@SpringBootApplication)"></a>创建主程序(@SpringBootApplication)</h2><p>接下来要创建主程序，执行测试的时候，就直接运行主程序即可。创建时<strong>建议为主程序建立一个包</strong>，包名推荐<code>com.xxx.xxx.boot</code><br>主程序<strong>类上</strong>需要使用<code>@SpringBootApplication</code>注解来标记。<br>其作用是：表明这是一个SpringBoot应用，以及，指定组件扫描起始包<br>※关于包扫描参见「SpringBoot2——依赖管理、starter导入与包结构」</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span>：这是一个SpringBoot应用，组件从此包开始扫描</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写业务-Controller"><a href="#编写业务-Controller" class="headerlink" title="编写业务(@Controller)"></a>编写业务(@Controller)</h2><p>编写业务建议在<strong>主程序的子包中完成</strong>，创建包名推荐<code>com.xxx.xxx.boot.controller</code><br>业务<strong>类上</strong>需要用<code>@Controller</code>注解。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以不写 <span class="doctag">@Controller</span> 和 <span class="doctag">@ResponseBody</span> 然后在类上写 <span class="doctag">@RestController</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ResponseBody</span> 可以和 <span class="doctag">@Controller</span> 一同写在类上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot 2!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了如下注解<br>|注解|说明|<br>|:-:|:-:|<br>|@Controller|标记这是一个业务类|<br>|@ResponseBody|返回【字符串】给浏览器<br/>可以标记在类上，也可以标在方法上|<br>|@RestController|是@Controller和@ResponseBody的复合&lt;br&gt;标在类上|<br>|@RequestMapping(“/hello”)|映射http请求，请求内容为括号内内容|</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>直接运行main方法</p><h2 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h2><p>在<code>resources</code>目录下，创建<code>application.properties</code>文件，在里面写配置可以覆盖SpringBoot原有的默认配置。<br>比如修改tomcat端口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8888</span><br></pre></td></tr></table></figure><h2 id="简化部署"><a href="#简化部署" class="headerlink" title="简化部署"></a>简化部署</h2><p>在 pom.xml 中添加如下内容，然后点击左边Maven工具栏，选中<code>clean</code>和<code>package</code>即可自动部署成<code>jar</code>包，直接在目标服务器执行即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>※如果<code>spring-boot-maven-plugin</code>报错“不存在”，请手动加入<code>&lt;version&gt;</code>表情，版本和<code>&lt;parent&gt;</code>中的版本一致<br>※运行过程如有中断：取消掉cmd的快速编辑模式</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web编程 </tag>
            
            <tag> 固定写法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—File类与递归</title>
      <link href="/2021/09/28/Java%E5%9F%BA%E7%A1%80%E2%80%94File%E7%B1%BB%E4%B8%8E%E9%80%92%E5%BD%92/"/>
      <url>/2021/09/28/Java%E5%9F%BA%E7%A1%80%E2%80%94File%E7%B1%BB%E4%B8%8E%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>此部分记录了File类与递归的使用作为IO流部分的铺垫</p><p>File类的部分主要涉及「File类的创建、判断、获取路径与文件名、删除」等的操作</p><p>递归部分主要包括递归的含义以及使用「递归实现遍历目录」</p><span id="more"></span><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="File类概述与构造方法"><a href="#File类概述与构造方法" class="headerlink" title="File类概述与构造方法"></a>File类概述与构造方法</h3><p><strong>概述</strong></p><ul><li>它是文件和目录路径名的抽象表示</li><li>文件和目录是可以通过File封装成对象的</li><li>具体文件可存在也可不存在</li></ul><p><strong>构造函数</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">File(String pathname)</td><td align="center">给定的路径名字符串转换为抽象路径名 创建新的 File实例</td></tr><tr><td align="center">File(String parent, String child)</td><td align="center">从父路径名字符串+子路径名字符串 创建新的 File实例</td></tr><tr><td align="center">File(File parent, String child)</td><td align="center">从父抽象路径名+子路径名字符串 创建新的 File实例</td></tr></tbody></table><p><strong>绝对路径 与 相对路径</strong></p><ul><li>绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如：E:\itcast\java.txt</li><li>相对路径：必须使用取自其他路径名的信息进行解释。例如：myFile\java.txt</li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//File(String pathname)：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。</span></span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\railm\\Downloads\\Aliyun_Download\\Java笔记\\二阶day8资料\\素材\\itcast\\java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//File(String parent, String child)：从父路径名字符串和子路径名字符串创建新的 File实例。</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\railm\\Downloads\\Aliyun_Download\\Java笔记\\二阶day8资料\\素材\\itcast&quot;</span>, <span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//File(File parent, String child)：从父抽象路径名和子路径名字符串创建新的 File实例。</span></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">&quot;File(File parent, String child)：从父抽象路径名和子路径名字符串创建新的 File实例。&quot;</span>);</span><br><span class="line">        File f4 = <span class="keyword">new</span> File(<span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f4);</span><br></pre></td></tr></table></figure><h3 id="File类的创建功能"><a href="#File类的创建功能" class="headerlink" title="File类的创建功能"></a>File类的创建功能</h3><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public boolean createNewFile()</td><td align="center">该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</td></tr><tr><td align="center">public boolean mkdir()</td><td align="center">创建由此抽象路径名命名的目录</td></tr><tr><td align="center">public boolean mkdirs()</td><td align="center">创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录</td></tr></tbody></table><p>※如果有<strong>同名</strong>的“文件夹”会造成文件创建失败</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求1：我要在E:\\itcast目录下创建一个文件java.txt</span></span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.createNewFile());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求2：我要在E:\\itcast目录下创建一个目录JavaSE</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\JavaSE&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求3：我要在E:\\itcast目录下创建一个多级目录JavaWEB\\HTML</span></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\JavaWEB\\HTML&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdirs());</span><br></pre></td></tr></table></figure><h3 id="File类判断和获取功能"><a href="#File类判断和获取功能" class="headerlink" title="File类判断和获取功能"></a>File类判断和获取功能</h3><p><strong>判断功能方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public boolean isDirectory()</td><td align="center">测试此抽象路径名表示的File是否为目录</td></tr><tr><td align="center">public boolean isFile()</td><td align="center">测试此抽象路径名表示的File是否为文件</td></tr><tr><td align="center">public boolean exists()</td><td align="center">测试此抽象路径名表示的File是否存在</td></tr></tbody></table><p><strong>获取功能方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public String getAbsolutePath()</td><td align="center">返回此抽象路径名的绝对路径名字符串</td></tr><tr><td align="center">public String getPath()</td><td align="center">将此抽象路径名转换为路径名字符串</td></tr><tr><td align="center">public String getName()</td><td align="center">返回由此抽象路径名表示的文件或目录的名称</td></tr><tr><td align="center">public String[] list()</td><td align="center">返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</td></tr><tr><td align="center">public File[] listFiles()</td><td align="center">返回此抽象路径名表示的目录中的文件和目录的File对象数组</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\java.txt&quot;</span>);  <span class="comment">//使用 myFile 指向当前文件目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        public boolean isDirectory()：测试此抽象路径名表示的File是否为目录</span></span><br><span class="line"><span class="comment">//        public boolean isFile()：测试此抽象路径名表示的File是否为文件</span></span><br><span class="line"><span class="comment">//        public boolean exists()：测试此抽象路径名表示的File是否存在</span></span><br><span class="line">        System.out.println(f.isDirectory());</span><br><span class="line">        System.out.println(f.isFile());</span><br><span class="line">        System.out.println(f.exists());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串</span></span><br><span class="line"><span class="comment">//        public String getPath()：将此抽象路径名转换为路径名字符串</span></span><br><span class="line"><span class="comment">//        public String getName()：返回由此抽象路径名表示的文件或目录的名称</span></span><br><span class="line">        System.out.println(f.getAbsoluteFile());</span><br><span class="line">        System.out.println(f.getPath());</span><br><span class="line">        System.out.println(f.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        public String[] list()：返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</span></span><br><span class="line"><span class="comment">//        public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组</span></span><br><span class="line"><span class="comment">//        --数组需要遍历哦--</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast&quot;</span>);</span><br><span class="line">        String[] s = f2.list();</span><br><span class="line">        <span class="keyword">for</span>(String st : s)&#123;</span><br><span class="line">            System.out.println(st);</span><br><span class="line">        &#125;</span><br><span class="line">        File[] ft = f2.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File file : ft)&#123;</span><br><span class="line">            System.out.println(file);<span class="comment">//打印路径</span></span><br><span class="line">            System.out.println(file.getName());<span class="comment">//和 f2.list() 结果一致，给出文件名</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//意义:取出所有文件名,规避目录</span></span><br><span class="line">            <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                System.out.println(file.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="File类删除功能"><a href="#File类删除功能" class="headerlink" title="File类删除功能"></a>File类删除功能</h3><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public boolean delete()</td><td align="center">删除由此抽象路径名表示的文件或目录</td></tr></tbody></table><p>※对于删除文件夹，如果里面有文件，需要先删除文件</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\java.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//目录下创建java.txt</span></span><br><span class="line">        System.out.println(f1.createNewFile());</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line">        <span class="comment">//创建文件夹</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\itcast2&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line">        <span class="comment">//删除文件夹</span></span><br><span class="line">        System.out.println(f2.delete());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 目录套文件 */</span></span><br><span class="line">        <span class="comment">//创建目录并创建文件</span></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\itcast3&quot;</span>);</span><br><span class="line">        f3.mkdir();</span><br><span class="line">        File f4 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\itcast3\\java.txt&quot;</span>);</span><br><span class="line">        f4.createNewFile();</span><br><span class="line">        <span class="comment">//创建文件之前应该创建目录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除itcast目录(目录内有内容),需要先删除内容</span></span><br><span class="line">        System.out.println(f4.delete());</span><br><span class="line">        System.out.println(f3.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="递归概述"><a href="#递归概述" class="headerlink" title="递归概述"></a>递归概述</h3><p>递归式是方法自己调用自己</p><p><strong>注意事项</strong></p><ul><li>递归一定要有出口，否则内存溢出</li><li>递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出</li></ul><h3 id="递归遍历目录"><a href="#递归遍历目录" class="headerlink" title="递归遍历目录"></a>递归遍历目录</h3><p><strong>思路</strong></p><ol><li>根据给定的路径创建一个File对象</li><li>定义一个方法，用于获取给定目录下的所有内容，参数为第1步创建的File对象</li><li>获取给定的File目录下所有的文件或者目录的File数组</li><li>遍历该File数组，得到每一个File对象</li><li>判断该File对象是否是目录<br>是：递归调用<br>不是：获取绝对路径输出在控制台</li><li>调用方法</li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\railm\\Downloads\\Aliyun_Download\\Java笔记\\二阶day8资料\\素材\\itcast&quot;</span>);</span><br><span class="line">        getAllFilePath(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFilePath</span><span class="params">(File f)</span></span>&#123;</span><br><span class="line">        File[] fileArray = f.listFiles();</span><br><span class="line">        <span class="comment">//保证文件健壮性，做个非空判断</span></span><br><span class="line">        <span class="keyword">if</span>(fileArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File file : fileArray) &#123;</span><br><span class="line"><span class="comment">//                判断该File对象是否是目录</span></span><br><span class="line"><span class="comment">//                是：递归调用</span></span><br><span class="line"><span class="comment">//                不是：获取绝对路径输出在控制台</span></span><br><span class="line">                <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                    getAllFilePath(file);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(file.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—类加载器与反射</title>
      <link href="/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>本文共分为类加载器和反射两个主题的内容。</p><p>类加载部分讲述了类加载的步骤、JVM类加载机制与加载器等理论性内容。</p><p>反射部分讲述了反射的基本使用，共分为「反射的概述、反射获取类与成员并使用、通过“外部文件”利用“反射”使用不同类和方法」三个部分。</p><span id="more"></span><h1 id="类加载器部分"><a href="#类加载器部分" class="headerlink" title="类加载器部分"></a>类加载器部分</h1><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><ul><li>就是指将class文件读入内存，并为之创建一个 java.lang.Class 对象</li><li>任何类被使用时，系统都会为之建立一个 java.lang.Class 对象<h3 id="类的连接"><a href="#类的连接" class="headerlink" title="类的连接"></a>类的连接</h3></li><li>验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致</li><li>准备阶段：负责为类的类变量分配内存，并设置默认初始化值</li><li>解析阶段：将类的二进制数据中的符号引用替换为直接引用<h3 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h3></li><li>在该阶段，主要就是对类变量进行初始化</li></ul><h3 id="类的初始化步骤"><a href="#类的初始化步骤" class="headerlink" title="类的初始化步骤"></a>类的初始化步骤</h3><ul><li>假如类还未被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还未被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li><li>*※注意**：在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3</li></ul><h3 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h3><ul><li>创建类的实例</li><li>调用类的类方法</li><li>访问类或者接口的类变量，或者为该类变量赋值</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li><li>初始化某个类的子类</li><li>直接使用java.exe命令来运行某个主类</li></ul><h2 id="JVM的类加载机制"><a href="#JVM的类加载机制" class="headerlink" title="JVM的类加载机制"></a>JVM的类加载机制</h2><ul><li>全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入<br>即：【如无指定<strong>全由这个加载器来加载</strong>】</li><li>父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类<br>即：【<strong>先有父类加载，加不了换自己</strong>】<br>缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区</li></ul><h2 id="Java中的内置类加载器"><a href="#Java中的内置类加载器" class="headerlink" title="Java中的内置类加载器"></a>Java中的内置类加载器</h2><ul><li>Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为<strong>null</strong> ，并且没有父null</li><li><strong>Platform</strong> class loader：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先定义的JavaSE平台API，其实现类和JDK特定的运行时类</li><li>System class loader：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类。</li></ul><p><strong>类加载器的继承关系</strong>：System的父加载器为Platform，而Platform的父加载器为Bootstrap</p><h2 id="ClassLoader的方法"><a href="#ClassLoader的方法" class="headerlink" title="ClassLoader的方法"></a>ClassLoader的方法</h2><ul><li>static ClassLoader getSystemClassLoader() 返回用于委派的系统类加载器</li><li>ClassLoader getParent()  返回父类加载器进行委派</li></ul><h1 id="反射部分"><a href="#反射部分" class="headerlink" title="反射部分"></a>反射部分</h1><h2 id="反射的概述【理解】"><a href="#反射的概述【理解】" class="headerlink" title="反射的概述【理解】"></a>反射的概述【理解】</h2><p>是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。<br>由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展</p><h2 id="反射获取类与成员并使用"><a href="#反射获取类与成员并使用" class="headerlink" title="反射获取类与成员并使用"></a>反射获取类与成员并使用</h2><h3 id="获取Class类对象（三种）"><a href="#获取Class类对象（三种）" class="headerlink" title="获取Class类对象（三种）"></a>获取Class类对象（三种）</h3><p><strong>方法</strong></p><ol><li>【最方便】使用类的class属性来获取该类对应的Class对象。举例：Student.class将会返回Student类对应的Class对象（常<strong>用在传入Construtor的传参</strong>）</li><li>调用对象的getClass()方法，返回该对象所属类对应的Class对象。该方法是Object类中的方法，所有的Java对象都可以调用该方法</li><li>【可由配置文件导入参数】使用Class类中的静态方法forName(String className)，该方法需要传入字符串参数，该字符串参数的值是某个类的全路径，也就是完整包名的路径</li></ol><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//1:使用类的class属性来获取该类对应的Class对象。举例：Student.class将会返回Student类对应的Class对象</span><br><span class="line">        Class&lt;Student&gt; c1 = Student.class;</span><br><span class="line">        System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        Class&lt;Student&gt; c2 = Student.class;</span><br><span class="line">        System.out.println(c1 == c2);//true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2:调用对象的getClass()方法，返回该对象所属类对应的Class对象</span><br><span class="line">//该方法是Object类中的方法，所有的Java对象都可以调用该方法</span><br><span class="line">        Student s = new Student();</span><br><span class="line">        Class&lt;? extends Student&gt; c3 = s.getClass();</span><br><span class="line">        System.out.println(c1 == c3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//3:使用Class类中的静态方法forName(String className)，该方法需要传入字符串参数，该字符串参数的值是某个类的全路径，也就是完整包名的路径</span><br><span class="line">        Class&lt;?&gt; c4 = Class.forName(&quot;com.itheima_02.Student&quot;);</span><br><span class="line">        System.out.println(c1 == c4);</span><br></pre></td></tr></table></figure><h3 id="反射获取【构造方法】并使用"><a href="#反射获取【构造方法】并使用" class="headerlink" title="反射获取【构造方法】并使用"></a>反射获取【构造方法】并使用</h3><p><strong>Class类中用于获取【构造方法】的方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Constructor&lt;?&gt;[] getConstructors()</td><td align="center">返回所有<strong>公共</strong>构造方法对象的【数组】</td></tr><tr><td align="center">Constructor&lt;?&gt;[] getDeclaredConstructors()</td><td align="center">返回所有构造方法对象的【数组】</td></tr><tr><td align="center">Constructor getConstructor(Class&lt;?&gt;… parameterTypes)</td><td align="center">返回单个<strong>公共</strong>构造方法对象</td></tr><tr><td align="center">Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td align="center">返回单个构造方法对象</td></tr></tbody></table><p><strong>Constructor类中用于创建对象的方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">T    newInstance(Object… initargs)</td><td align="center">使用此 构造器对象表示的构造方法，使用指定的初始化参数创建和初始化构造函数声明类的新实例</td></tr></tbody></table><p><strong>※暴力反射</strong>：当使用私有构造方法创建对象时，需要取消访问检查，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line"><span class="comment">//获取class对象</span></span><br><span class="line">        Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造方法(对象数组)：</span></span><br><span class="line">        <span class="comment">// 【法一：公共构造方法】Constructor&lt;?&gt;[] getConstructors() ———— 返回一个包含和 Constructor 对象数组，反映了该对象所有公共的构造函数</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons = c.getConstructors();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【法二：所有构造方法】Constructor&lt;?&gt;[] getDeclaredConstructors() ———— 返回 构造器对象的数组， 构造器对象反映由此 类对象表示的类声明的所有构造函数。</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons2 = c.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor con :cons2)&#123;</span><br><span class="line">            System.out.println(con);<span class="comment">//返回所有构造方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造方法(单个对象)：</span></span><br><span class="line">        <span class="comment">//【法一：指定公共构造函数】构造器&lt;T&gt;getConstructor​(类&lt;?&gt;... parameterTypes) ———— 返回一个 构造器对象，该对象反映此 类对象所表示的类的指定公共构造函数。</span></span><br><span class="line">        <span class="comment">//【法二：指定构造函数】构造器&lt;T&gt;getDeclaredConstructor​(类&lt;?&gt;... parameterTypes) ———— 返回一个 构造器对象，该对象反映此 类对象所表示的类或接口的指定构造函数。</span></span><br><span class="line">        <span class="comment">//参数：你要获得的构造方法的参数个数和数据类型的字节码对象</span></span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//利用反射创建对象</span></span><br><span class="line">        <span class="comment">//构造器提供有关类的单个构造函数的信息和访问权限。 ———— TnewInstance​(Object... initargs)   使用此 构造器对象表示的构造方法，使用指定的初始化参数创建和初始化构造函数声明类的新实例。</span></span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取【成员变量】并使用"><a href="#反射获取【成员变量】并使用" class="headerlink" title="反射获取【成员变量】并使用"></a>反射获取【成员变量】并使用</h3><p><strong>Class类中获取成员变量的方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Field[] getFields()</td><td align="center">返回所有公共成员变量对象的数组</td></tr><tr><td align="center">Field[] getDeclaredFields()</td><td align="center">返回所有成员变量对象的数组</td></tr><tr><td align="center">Field getField(String name)</td><td align="center">返回单个公共成员变量对象</td></tr><tr><td align="center">Field getDeclaredField(String name)</td><td align="center">返回单个成员变量对象</td></tr></tbody></table><p><strong>Field中用于给成员变量赋值的方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void    set (Object obj, Object value)</td><td align="center">将指定对象参数上此 字段对象表示的字段设置为指定的新值</td></tr></tbody></table><p><strong>※暴力反射</strong>：当使用私有成员变量创建时，需要取消访问检查，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line"><span class="comment">//创建【成员函数(Field 字段)】反射对象</span></span><br><span class="line">        <span class="comment">//FieldgetField (String name) ———— 返回 字段对象，该对象反映此 类对象表示的类或接口的指定公共成员字段。</span></span><br><span class="line">        <span class="comment">//Field[]getFields() ———— 返回一个包含 字段对象的数组， 字段对象反映此 类对象所表示的类或接口的所有可访问公共字段。</span></span><br><span class="line">        <span class="comment">//FieldgetDeclaredField (String name) ———— 返回 字段对象，该对象反映此 类对象表示的类或接口的指定声明字段。</span></span><br><span class="line">        <span class="comment">//Field[]getDeclaredFields() ———— 返回 字段对象的数组， 字段对象反映由此 类对象表示的类或接口声明的所有字段。</span></span><br><span class="line"></span><br><span class="line">        Field[] fields = c.getFields();</span><br><span class="line">        Field[] declaredFields = c.getDeclaredFields();</span><br><span class="line">        Field addressField = c.getField(<span class="string">&quot;address&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用【成员变量(Field 字段)】</span></span><br><span class="line">        <span class="comment">//获取无参构造方法反射</span></span><br><span class="line">        Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用【成员方法】</span></span><br><span class="line">        <span class="comment">//voidset (Object obj, Object value) ———— 将指定对象参数上此 字段对象表示的字段设置为指定的新值。</span></span><br><span class="line">        addressField.set(obj,<span class="string">&quot;HK&quot;</span>);<span class="comment">//给obj的成员变量addressField赋值为”HK“</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取【成员方法】并使用"><a href="#反射获取【成员方法】并使用" class="headerlink" title="反射获取【成员方法】并使用"></a>反射获取【成员方法】并使用</h3><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Method[] getMethods()</td><td align="center">返回所有公共成员方法对象的数组，包括继承的</td></tr><tr><td align="center">Method[] getDeclaredMethods()</td><td align="center">返回所有成员方法对象的数组，不包括继承的</td></tr><tr><td align="center">Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td align="center">返回单个公共成员方法对象</td></tr><tr><td align="center">Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td align="center">返回单个成员方法对象</td></tr></tbody></table><p><strong>使用</strong><br>| 方法名 | 说明 |<br>| :—-: | :—-: |<br>Object invoke(Object obj,Object… args) |调用obj对象的成员方法，参数是args,返回值是Object类型</p><p><strong>※暴力反射</strong>：当使用私有成员方法时，需要取消访问检查，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="通过“外部文件”利用“反射”使用不同类和方法"><a href="#通过“外部文件”利用“反射”使用不同类和方法" class="headerlink" title="通过“外部文件”利用“反射”使用不同类和方法"></a>通过“外部文件”利用“反射”使用不同类和方法</h2><p>外部文件需要通过IO流的特殊操作流<code>Properties</code>来实现读取成为STring ，以便进行反射操作</p><p>~~~java<br>public class ReflectTest02 {<br>    public static void main(String[] args) throws ClassNotFoundException, IOException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {</p><pre><code>    /* *    此时外部文件的格式：    ***********    * class.txt    * className=xxx    * methodName=xxx    ***********    * */        //加载数据 - 利用”特殊操作流“    Properties prop = new Properties();    FileReader fr = new FileReader(&quot;myReflect\\class.txt&quot;);    prop.load(fr);    fr.close();    /*这样就拿到文件内数据了*/    String className = prop.getProperty(&quot;className&quot;);    String methodName = prop.getProperty(&quot;methodName&quot;);    //通过反射使用    Class&lt;?&gt; c = Class.forName(className);    Constructor&lt;?&gt; con = c.getConstructor();    Object obj = con.newInstance();    Method m = c.getMethod(methodName);    m.invoke(obj);&#125;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
            <tag> 类加载器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—Stream流</title>
      <link href="/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94Stream%E6%B5%81/"/>
      <url>/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>此部分记录了使用Java进行流式编程的思想与使用方法，共分为「Stream流思想、Stream流的使用、Stream流的收集操作」三个基础部分。因为流的中间操作方法较多，所以另外提供了一个流操作的综合实例。</p><span id="more"></span><h2 id="Stream流思想"><a href="#Stream流思想" class="headerlink" title="Stream流思想"></a>Stream流思想</h2><p>Stream流的操作一般分为三个流程：生成流 、中间操作、终结操作</p><p><img src="01.png" alt="图片"></p><h2 id="Stream流的使用"><a href="#Stream流的使用" class="headerlink" title="Stream流的使用"></a>Stream流的使用</h2><h3 id="Stream流的生成"><a href="#Stream流的生成" class="headerlink" title="Stream流的生成"></a>Stream流的生成</h3><p><strong>方法</strong></p><p>Stream流可以直接生成Collection体系集合以及数组，对于Map体系的集合，需要把Map转成Set集合</p><table><thead><tr><th align="center">数据类型</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td align="center">Collection体系集合</td><td>default Stream stream()</td><td>默认方法stream()生成流</td></tr><tr><td align="center">数组</td><td>static of(T… Values)</td><td>静态方法生成数组流</td></tr><tr><td align="center">Map体系</td><td>需要使用 keySet() values() entryStream() <br />来将Map体系转为Set集合，再利用 stream() 转为流</td><td>间接生成</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//Collection体系的集合可以使用默认方法stream ()生成流</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; listStream = list.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; setStream = set.stream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Map体系的集合【间接】的生成流</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">        Stream&lt;Integer&gt; valueStream = map.values().stream();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//数组可以通过Stream接口的静态方法of (T... values)生成流</span></span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; strArrayStream = Stream.of(strArray);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String流的中间操作"><a href="#String流的中间操作" class="headerlink" title="String流的中间操作"></a>String流的中间操作</h2><p><strong>方法</strong></p><p>这里方法较多，可以参考文档使用</p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Stream filter(Predicate predicate)</td><td align="center">用于对流中的数据进行过滤</td></tr><tr><td align="center">Stream limit(long maxSize)</td><td align="center">返回此流中的元素组成的流，截取前指定参数个数的数据</td></tr><tr><td align="center">Stream skip(long n)</td><td align="center">跳过指定参数个数的数据，返回由该流的剩余元素组成的流</td></tr><tr><td align="center">static Stream concat(Stream a, Stream b)</td><td align="center">合并a和b两个流为一个流</td></tr><tr><td align="center">Stream distinct()</td><td align="center">返回由该流的不同元素（根据Object.equals(Object) ）组成的流</td></tr><tr><td align="center">Stream sorted()</td><td align="center">返回由此流的元素组成的流，根据自然顺序排序</td></tr><tr><td align="center">Stream sorted(Comparator comparator)</td><td align="center">返回由该流的元素组成的流，根据提供的Comparator进行排序</td></tr><tr><td align="center">Stream map(Function mapper)</td><td align="center">返回由给定函数应用于此流的元素的结果组成的流</td></tr><tr><td align="center">IntStream mapToInt(ToIntFunction mapper)</td><td align="center">返回一个IntStream其中包含将给定函数应用于此流的元素的结果</td></tr></tbody></table><h3 id="Stream流的终结操作"><a href="#Stream流的终结操作" class="headerlink" title="Stream流的终结操作"></a>Stream流的终结操作</h3><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void forEach(Consumer action)</td><td align="center">对此流的每个元素执行操作</td></tr><tr><td align="center">long count()</td><td align="center">返回此流中的元素数</td></tr></tbody></table><h2 id="流的收集操作——工具类Collectors"><a href="#流的收集操作——工具类Collectors" class="headerlink" title="流的收集操作——工具类Collectors"></a>流的收集操作——工具类Collectors</h2><p><strong>作用</strong></p><p>把流收集成为“List”“Set”“Map”等集合</p><p>需要使用 <code>collect(Collectors.×××)</code> 其中括号里的 Collectors 是一个工具类</p><p><strong>Collectors方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public static Collectors toList()</td><td align="center">把元素收集到List集合中</td></tr><tr><td align="center">public static Collectors toSet()</td><td align="center">把元素收集到Set集合中</td></tr><tr><td align="center">public static Collectors toMap(Function keyMapper,Function valueMapper)</td><td align="center">把元素收集到Map集合中</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建List集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求1：得到名字为3个字的流</span></span><br><span class="line">        Stream&lt;String&gt; listStream = list.stream().filter(s -&gt; s.length() == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求2：把使用Stream流操作完毕的数据收集到List集合中并遍历</span></span><br><span class="line">        List&lt;String&gt; names = listStream.collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">for</span>(String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Set集合对象</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">20</span>);</span><br><span class="line">        set.add(<span class="number">30</span>);</span><br><span class="line">        set.add(<span class="number">33</span>);</span><br><span class="line">        set.add(<span class="number">35</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求3：得到年龄大于25的流</span></span><br><span class="line">        Stream&lt;Integer&gt; setStream = set.stream().filter(age -&gt; age &gt; <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求4：把使用Stream流操作完毕的数据收集到Set集合中并遍历</span></span><br><span class="line">        Set&lt;Integer&gt; ages = setStream.collect(Collectors.toSet());</span><br><span class="line">        <span class="keyword">for</span>(Integer age : ages) &#123;</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成</span></span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;王祖贤,33&quot;</span>, <span class="string">&quot;柳岩,25&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求5：得到字符串中年龄数据大于28的流</span></span><br><span class="line">        Stream&lt;String&gt; arrayStream = Stream.of(strArray).filter(s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求6：把使用Stream流操作完毕的数据收集到Map集合中并遍历，字符串中的姓名作键，年龄作值</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = arrayStream.collect(Collectors.toMap(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>], s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])));</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;,&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流的综合使用实例"><a href="#流的综合使用实例" class="headerlink" title="流的综合使用实例"></a>流的综合使用实例</h2><p><strong>实例要求</strong></p><p>现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作：</p><ol><li>男演员只要名字为3个字的前三人</li><li>女演员只要姓林的，并且不要第一个</li><li>把过滤后的男演员姓名和女演员姓名合并到一起</li><li>把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法</li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        ArrayList&lt;String&gt; manList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        manList.add(<span class="string">&quot;周润发&quot;</span>);</span><br><span class="line">        manList.add(<span class="string">&quot;成龙&quot;</span>);</span><br><span class="line">        manList.add(<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        manList.add(<span class="string">&quot;吴京&quot;</span>);</span><br><span class="line">        manList.add(<span class="string">&quot;周星驰&quot;</span>);</span><br><span class="line">        manList.add(<span class="string">&quot;李连杰&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; womanList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        womanList.add(<span class="string">&quot;林心如&quot;</span>);</span><br><span class="line">        womanList.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        womanList.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        womanList.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        womanList.add(<span class="string">&quot;林志玲&quot;</span>);</span><br><span class="line">        womanList.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; manStream = manList.stream();</span><br><span class="line">        Stream&lt;String&gt; womanStream = womanList.stream();</span><br><span class="line">        Stream.concat(manStream.filter(s -&gt; s.length() == <span class="number">3</span>).limit(<span class="number">3</span>), womanStream.filter(s -&gt; s.startsWith(<span class="string">&quot;林&quot;</span>)).skip(<span class="number">1</span>)).map(Actor::<span class="keyword">new</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>※字符串开头字符判断方法：<code>s.startsWith(&quot;x&quot;)</code></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—函数式接口</title>
      <link href="/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要记录了Java函数式接口的使用方法以及常用的函数式接口，函数式接口(Functional Interface)是Java 8对一类特殊类型的接口的称呼。 这类接口只定义了唯一的抽象方法的接口（除了隐含的Object对象的公共方法）。函数是接口是因为Lambda表达式必须要依赖于上下文存在，故此类接口是Lambda表达式（包括方法引用）的一种实现方式。</p><p>文章结构分为「函数式接口的概述、函数是接口的使用方式、常用的函数式接口」三个部分。</p><span id="more"></span><h2 id="函数式接口的概述"><a href="#函数式接口的概述" class="headerlink" title="函数式接口的概述"></a>函数式接口的概述</h2><p><strong>概念</strong></p><ul><li>有且仅有一个抽象方法的接口，即可以使用Lambda表达式的接口</li><li>函数式接口可以用作【参数传递】&amp;【局部变量】</li></ul><p><strong>函数式接口标记</strong><br><code>@FunctionalInterface</code>(建议加上)</p><p>放在接口定义的上方：如果接口是函数式接口，编译通过；如果不是，编译失败</p><h2 id="函数式接口的使用方式"><a href="#函数式接口的使用方式" class="headerlink" title="函数式接口的使用方式"></a>函数式接口的使用方式</h2><h3 id="函数式接口作为方法的参数-以Runnable-为例"><a href="#函数式接口作为方法的参数-以Runnable-为例" class="headerlink" title="函数式接口作为方法的参数(以Runnable()为例)"></a>函数式接口作为方法的参数(以Runnable()为例)</h3><p><strong>要求</strong><br>定义一个类(RunnableDemo)，在类中提供两个方法：</p><p>一个方法是：startThread(Runnable r) 方法参数Runnable是一个函数式接口</p><p>一个方法是：主方法，在主方法中调用startThread方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在主方法中调用startThread方法</span></span><br><span class="line">        <span class="comment">//匿名内部类的方式</span></span><br><span class="line">        startThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程 - 匿名内部类的方式&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//Lambda表达式的方式</span></span><br><span class="line">        startThread(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程 - Lambda表达式的方式&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line"><span class="comment">//        Thread t = new Thread(r);</span></span><br><span class="line"><span class="comment">//        t.start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数式接口作为方法的返回值-以Comparator-为例"><a href="#函数式接口作为方法的返回值-以Comparator-为例" class="headerlink" title="函数式接口作为方法的返回值(以Comparator() 为例)"></a>函数式接口作为方法的返回值(以Comparator() 为例)</h3><p><strong>要求</strong></p><p>定义一个类(ComparatorDemo)，在类中提供两个方法：</p><p>一个方法是：Comparator getComparator() 方法返回值Comparator是一个函数式接口</p><p>一个方法是主方法，在主方法中调用getComparator方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造使用场景</span></span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        array.add(<span class="string">&quot;abcdefghijklmn&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;199&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前&quot;</span> + array);</span><br><span class="line"></span><br><span class="line">        Collections.sort(array, getComparator());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序后&quot;</span> + array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">getComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名内部类实现</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s1.length() - s2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda表达式方式</span></span><br><span class="line">        <span class="keyword">return</span> (s1, s2) -&gt; s1.length() - s2.length(); <span class="comment">//函数式接口作为方法的返回值，使用Lambda接口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用的函数式接口"><a href="#常用的函数式接口" class="headerlink" title="常用的函数式接口"></a>常用的函数式接口</h2><h3 id="生产型接口——Supplier"><a href="#生产型接口——Supplier" class="headerlink" title="生产型接口——Supplier"></a>生产型接口——Supplier</h3><p><strong>作用</strong></p><p>如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据供我们使用。</p><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">T get()</td><td align="center">按照某种实现逻辑(由Lambda表达式实现)返回一个数据</td></tr></tbody></table><p><strong>示例</strong></p><p><strong>案例需求</strong><br>定义一个类(SupplierTest)，在类中提供两个方法</p><p>​    一个方法是：int getMax(Supplier sup) 用于返回一个int数组中的最大值</p><p>​    一个方法是主方法，在主方法中调用getMax方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxValue = getMax(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">                max = Math.max(max, arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 SupPlier&lt;T&gt; 的 get() 方法返回一个最大值，具体实现由主类中的Lambda实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费型接口——Consumer"><a href="#消费型接口——Consumer" class="headerlink" title="消费型接口——Consumer"></a>消费型接口——Consumer</h3><p><strong>作用</strong></p><p>对传入参数执行或依次执行操作，它消费的数据的数据类型由泛型指定</p><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void accept(T t)</td><td align="center">对给定的参数执行此操作</td></tr><tr><td align="center">default Consumer andThen(Consumer after)</td><td align="center">返回一个组合的Consumer，依次执行此操作，然后执行after操作<br />采用链式编程</td></tr></tbody></table><p><strong>示例</strong></p><p><strong>案例需求</strong><br>String[] strArray = {“林青霞,30”, “张曼玉,35”, “王祖贤,33”};</p><p>字符串数组中有多条信息，请按照格式：“姓名：XX,年龄：XX”的格式将信息打印出来</p><p><strong>要求</strong><br>把打印姓名的动作作为第一个Consumer接口的Lambda实例</p><p>把打印年龄的动作作为第二个Consumer接口的Lambda实例</p><p>将两个Consumer接口按照顺序组合到一起使用</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;小林,30&quot;</span>, <span class="string">&quot;小张,35&quot;</span>, <span class="string">&quot;小王,33&quot;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//con1 与 con2 的操作在此处定义</span></span><br><span class="line">        printNameAge(strArray, s -&gt; System.out.print(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>]), (s -&gt; System.out.println(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNameAge</span><span class="params">(String[] strArray, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String s : strArray)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对传入参数 s ，先进行 con1 的操作；再进行 con2 的操作。</span></span><br><span class="line">            <span class="comment">//con1 与 con2 的操作由主类Lambda表达式定义</span></span><br><span class="line">            con1.andThen(con2).accept(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断用接口——Predicate"><a href="#判断用接口——Predicate" class="headerlink" title="判断用接口——Predicate"></a>判断用接口——Predicate</h3><p><strong>作用</strong></p><p>Predicate接口通常用于判断参数是否满足指定的条件</p><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">boolean test(T t)</td><td align="center">对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回一个布尔值</td></tr><tr><td align="center">default Predicate negate()</td><td align="center">返回一个逻辑的否定，对应逻辑非</td></tr><tr><td align="center">default Predicate and(Predicate other)</td><td align="center">返回一个组合判断，对应短路与</td></tr><tr><td align="center">default Predicate or(Predicate other)</td><td align="center">返回一个组合判断，对应短路或</td></tr></tbody></table><p><strong>示例</strong></p><ul><li><p>练习描述</p><ul><li><p>String[] strArray = {“林青霞,30”, “柳岩,34”, “张曼玉,35”, “貂蝉,31”, “王祖贤,33”};</p></li><li><p>字符串数组中有多条信息，请通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中，并遍历ArrayList集合</p></li><li><p>同时满足如下要求：</p><p>姓名长度大于2；年龄大于33</p></li></ul></li><li><p>分析</p><ul><li>有两个判断条件,所以需要使用两个Predicate接口,对条件进行判断</li><li>必须同时满足两个条件,所以可以使用and方法连接两个判断条件</li></ul></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;柳岩,34&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;貂蝉,31&quot;</span>, <span class="string">&quot;王祖贤,33&quot;</span>&#125;;</span><br><span class="line">        ArrayList&lt;String&gt; array = myFilter(strArray, s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length() &gt; <span class="number">2</span>, s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">33</span>);</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">myFilter</span><span class="params">(String[] strArray, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s : strArray)&#123;</span><br><span class="line">            <span class="comment">//这里是对 s 判断一下 pre2 和 pre1 的真假，然后进行与操作</span></span><br><span class="line">            <span class="comment">//至于 pre1 和 pre2 的判断过程，由主流的Lambda表达式给出</span></span><br><span class="line">            <span class="keyword">if</span>(pre1.and(pre2).test(s))&#123;</span><br><span class="line">                array.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据处理返回用接口——Function"><a href="#数据处理返回用接口——Function" class="headerlink" title="数据处理返回用接口——Function"></a>数据处理返回用接口——Function</h3><p><strong>作用</strong></p><p>Function&lt;T,R&gt;接口通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值。转换前的数据类型是 T ，转换后的数据类型是 R 。</p><p><strong>方法</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>R apply(T t)</td><td>将此函数应用于给定的参数</td></tr><tr><td>default Function andThen(Function after)</td><td>返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果</td></tr></tbody></table><p><strong>示例</strong></p><ul><li>练习描述<ul><li>String s = “林青霞,30”;<br>请按照我指定的要求进行操作：</li><li>1:将字符串截取得到数字年龄部分<br>2:将上一步的年龄字符串转换成为int类型的数据<br>3:将上一步的int数据加70，得到一个int结果，在控制台输出</li><li>请通过Function接口来实现函数拼接</li></ul></li><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;林青霞,30&quot;</span>;</span><br><span class="line">        Integer converted = convert(s, s1 -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]), s2 -&gt; s2 + <span class="number">70</span>);</span><br><span class="line">        System.out.println(converted);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">convert</span><span class="params">(String s, Function&lt;String, Integer&gt; fun1, Function&lt;Integer, Integer&gt; fun2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回处理结果，对 s 先进行 fun1 的运算，再进行 fun2 的运算</span></span><br><span class="line">        <span class="keyword">return</span> fun1.andThen(fun2).apply(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda表达式 </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—接口的组成更新</title>
      <link href="/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E6%88%90%E6%9B%B4%E6%96%B0/"/>
      <url>/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E6%88%90%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要记录了Java中接口的不同方法，Java随着版本更新提供了更多的接口方法，这些方法的出现使得接口中不再只能有抽象方法与常量，增加了程序的可维护性。</p><p>文章结构分为「接口组成更新的概述、接口的默认方法、接口的静态方法、接口的私有方法」四个部分。</p><span id="more"></span><h2 id="接口组成更新的概述"><a href="#接口组成更新的概述" class="headerlink" title="接口组成更新的概述"></a>接口组成更新的概述</h2><ul><li>常量 public static final</li><li>抽象方法 public abstract</li><li>默认方法(Java 8)</li><li>静态方法(Java 8)</li><li>私有方法(Java 9)</li></ul><h2 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h2><p><strong>格式</strong><br>public default 返回值类型 方法名(参数列表) {<strong>方法体</strong>}<br>※public可以省略<br><strong>注意</strong><br>默认方法不是抽象方法，实现类<strong>不强制重写</strong>，<strong>也可以重写</strong>，public 可以省略<br><strong>作用</strong><br>维护接口，增加功能<br><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的静态方法"><a href="#接口的静态方法" class="headerlink" title="接口的静态方法"></a>接口的静态方法</h2><p><strong>格式</strong><br>public static 返回值类型 方法名(参数列表) { }<br>※public可以省略<br><strong>注意</strong><br>只能通过<strong>接口名调用</strong><br><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接口内：</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show3-静态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">测试类：</span><br><span class="line">            Inter.show3();</span><br></pre></td></tr></table></figure><h2 id="接口的私有方法"><a href="#接口的私有方法" class="headerlink" title="接口的私有方法"></a>接口的私有方法</h2><p><strong>产生背景</strong><br>【静态方法】 与 【默认方法】给接口引入“方法体”，所以需要将“方法体内相同内容抽出来”，故必然会产生【私有方法】<br><strong>格式</strong></p><ul><li><strong>格式1</strong>：接口私有方法<br><code>private 返回值类型 方法名(参数列表) &#123; &#125;</code><br><strong>范例1</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>格式2</strong>：接口私有静态方法<br><code>private static 返回值类 方法名(参数列表) &#123; &#125;</code><br><strong>范例2</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>私有静态方法：能用到【接口静态方法】【接口默认方法】</li><li>私有方法：只能用【接口默认方法】</li></ul><p><strong>综合示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接口默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show2开始执行&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//接口默认方法接受【接口私有方法】、【接口私有静态方法】</span></span><br><span class="line">        show();</span><br><span class="line">        method();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;show2结束执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接口静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2开始执行&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//接口静态方法只接受【接口私有静态方法】</span></span><br><span class="line">        method();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;method2结束执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//接口私有方法(上面调用)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初级工程师&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中级工程师&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;高级工程师&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//接口私有静态方法(上面调用)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初级工程师&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中级工程师&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;高级工程师&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—Lambda表达式与方法引用</title>
      <link href="/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
      <url>/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要记录了Java中Lambda表达式的使用方式和方法引用。Lambda表达式是函数式编程思想的体现，函数式编程思想尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”。Lambda表达式遵循“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导。</p><p>方法引用是Lambda的孪生兄弟，与Lambda表达式同样可以根据上下文进行推导，使用方法引用可以减少代码复杂度。</p><p>文章结构分为「Lambda表达式的格式与使用、Lambda表达式与匿名内部类的区别、方法引用概述、Lambda表达式支持的方法引用」四个部分。</p><span id="more"></span><h2 id="Lambda表达式的格式与使用"><a href="#Lambda表达式的格式与使用" class="headerlink" title="Lambda表达式的格式与使用"></a>Lambda表达式的格式与使用</h2><p><strong>使用前提</strong></p><ul><li>必须要有<strong>接口</strong>，接口只有<strong>一个</strong>抽象方法</li><li>必须有<strong>上下文环境</strong>才能推到Lambda对应的接口</li></ul><h3 id="Lambda表达式的标准格式"><a href="#Lambda表达式的标准格式" class="headerlink" title="Lambda表达式的标准格式"></a>Lambda表达式的标准格式</h3><p><strong>格式</strong><br>标准格式由三要素组成：<strong>形式参数</strong>、<strong>箭头</strong>、<strong>代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(形式参数) -&gt; &#123;代码块(具体要做的事情)&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p><strong>示例要求</strong>：计算<code>x + y</code>，使用有参有返回的抽象方法</p><p><strong>代码实现：</strong></p><p>接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Addable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        useAddable((<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useAddable</span><span class="params">(Addable a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = a.add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p><code>useAddable(Addable a)</code>需要传入一个<code>Addable接口</code>的实现类。传入后，<code>useAddable(Addable a)</code>方法就可以调用<code>Addable接口</code>中的<code>a.add(int x, int y)</code>的方法。所以主类中我们就传入了一个Labmda表达式，相当于重写了接口类的<code> add(int x,int y)</code>方法。</p><p>此处也可以使用匿名内部类重写<code>a.add(int x, int y)</code>来实现，但较为麻烦，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useAddable(<span class="keyword">new</span> Addable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> x + y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式的缩略形式"><a href="#Lambda表达式的缩略形式" class="headerlink" title="Lambda表达式的缩略形式"></a>Lambda表达式的缩略形式</h3><p><strong>格式</strong></p><p>Lambda表达式可以有条件的缩略，具体缩略情况如下：</p><ol><li>省略参数类型</li><li>省略小括号：参数只有一个</li><li>省略大括号和分号，以及return：如果只有一条语句</li></ol><p><strong>示例</strong></p><p>用缩略写法表示上一个示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useAddable((x, y) -&gt; x + y);</span><br></pre></td></tr></table></figure><h2 id="Lambda表达式和匿名内部类的区别"><a href="#Lambda表达式和匿名内部类的区别" class="headerlink" title="Lambda表达式和匿名内部类的区别"></a>Lambda表达式和匿名内部类的区别</h2><ul><li>所需类型不同<ul><li>匿名内部类：可以是接口，也可以是抽象类，还可以是具体类</li><li>Lambda表达式：只能是接口</li></ul></li><li>使用限制不同<ul><li>如果接口抽象方法<strong>1个</strong>：都可以</li><li>如果接口抽象方法<strong>多个</strong>：<strong>匿名内部类</strong>only</li></ul></li><li>实现原理不同<ul><li>匿名内部类：编译之后，产生一个单独的.class字节码文件</li><li>Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成</li></ul></li></ul><h2 id="方法引用概述"><a href="#方法引用概述" class="headerlink" title="方法引用概述"></a>方法引用概述</h2><p><strong>方法引用符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::</span><br></pre></td></tr></table></figure><p><strong>推导与省略</strong></p><ul><li>如果使用Lambda，那么根据“可推导就是可省略”的原则，<strong>无需指定参数类型</strong>，<strong>也无需指定的重载形式</strong>，它们都将被自动推导</li><li>如果使用方法引用，也是同样可以根据上下文进行推导</li><li>方法引用是<strong>Lambda的孪生兄弟</strong></li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        usePrintable(System.out::println);<span class="comment">//方法引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usePrintable</span><span class="params">(Printable p)</span></span>&#123;</span><br><span class="line">        p.printInt(<span class="number">46</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda表达式支持的方法引用"><a href="#Lambda表达式支持的方法引用" class="headerlink" title="Lambda表达式支持的方法引用"></a>Lambda表达式支持的方法引用</h2><p>支持如下方法的方法引用：</p><ul><li>引用类方法</li><li>引用对象实例方法</li><li>引用类的实例方法</li><li>引用构造器</li></ul><h3 id="引用类方法"><a href="#引用类方法" class="headerlink" title="引用类方法"></a>引用类方法</h3><p><strong>格式</strong>：</p><p><code>类名::静态方法</code><br><strong>范例</strong>：</p><p><code>Integer::parseInt</code></p><p>其调用的方法是：<code>public static int parseInt(String s)</code></p><p><strong>示例</strong></p><p>练习：</p><ol><li>定义一个接口(Converter)，里面定义一个抽象方法：int convert(String s);</li><li>定义一个测试类(ConverterDemo)，在测试类中提供两个方法<br>一个方法是：useConverter(Converter c)<br>一个方法是主方法，在主方法中调用useConverter方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConverterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        useConverter((String s) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            return Integer.parseInt(s);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        useConverter(Integer::parseInt);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//Lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useConverter</span><span class="params">(Converter c)</span></span>&#123;</span><br><span class="line">        c.convert(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用对象实例方法"><a href="#引用对象实例方法" class="headerlink" title="引用对象实例方法"></a>引用对象实例方法</h3><p><strong>格式</strong></p><p><code>对象::成员方法</code></p><p><strong>范例</strong></p><p><code>&quot;HelloWorld&quot;::toUpperCase String</code></p><p>类中的方法：public String toUpperCase() 将此String所有字符转换为大写</p><p><strong>传参</strong></p><p>Lambda表达式被对象的实例方法替代的时候，它的<strong>形式参数全部传递</strong>给该方法作为参数</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintString ps = <span class="keyword">new</span> PrintString();<span class="comment">//类</span></span><br><span class="line">        usePrinter(ps::printUpper);<span class="comment">//的实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usePrinter</span><span class="params">(Printer p)</span></span>&#123;</span><br><span class="line">        p.printUpperCase(<span class="string">&quot;hfd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用类的实例放法"><a href="#引用类的实例放法" class="headerlink" title="引用类的实例放法"></a>引用类的实例放法</h3><p>引用类的实例方法，其实就是引用类中的成员方法</p><p><strong>格式</strong></p><p><code>类名::成员方法</code></p><p><strong>范例</strong></p><p><code>String::substring</code></p><p>使用的<code>public String substring(int beginIndex,int endIndex)</code></p><p>（从beginIndex开始到endIndex结束，截取字符串。返回一个子串，子串的长度为endIndex-beginIndex）</p><p><strong>传参</strong></p><p>Lambda表达式被类的实例方法替代的时候，<strong>第一个参数作为调用者</strong>，<strong>后面的参数全部传递给该方法作为参数</strong>。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Lambda</span></span><br><span class="line">        useMyString((String s, <span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; s.substring(x, y));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//引用类的实例方法</span></span><br><span class="line">        useMyString(String::substring);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式被类的实例方法替代的时候</span></span><br><span class="line">        <span class="comment">//第一个参数作为调用者</span></span><br><span class="line">        <span class="comment">//后面的参数全部传递给该方法作为参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useMyString</span><span class="params">(MyString my)</span></span>&#123;</span><br><span class="line">        System.out.println(my.mySubString(<span class="string">&quot;abcdefg&quot;</span>, <span class="number">2</span>, <span class="number">5</span>));;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用构造器（构造方法）"><a href="#引用构造器（构造方法）" class="headerlink" title="引用构造器（构造方法）"></a>引用构造器（构造方法）</h3><p><strong>格式</strong> ：</p><p><code>类名::new</code><br><strong>范例</strong> ：</p><p><code>Student::new</code></p><p><strong>传参</strong></p><p>Lambda表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数</p><p><strong>示例</strong><br>练习</p><ol><li><p>定义一个类(Student)，里面有两个成员变量(name,age) 并提供无参构造方法和带参构造方法，以及成员变量对应的get和set方法</p></li><li><p>定义一个接口(StudentBuilder)，里面定义一个抽象方法**<code>Student build(String name,int age);</code>**</p></li><li><p>定义一个测试类(StudentDemo)，在测试类中提供两个方法</p><p>一个方法是：useStudentBuilder(StudentBuilder s)</p><p>一个方法是主方法，在主方法中调用useStudentBuilder方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式标准写法：</span></span><br><span class="line"><span class="comment">//        useStudentBuilder((String name, int age) -&gt; &#123;</span></span><br><span class="line"><span class="comment">////            Student s = new Student(name, age);</span></span><br><span class="line"><span class="comment">////            return s;</span></span><br><span class="line"><span class="comment">//            return new Student(name, age);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        useStudentBuilder((String name, <span class="keyword">int</span> age) -&gt; <span class="keyword">new</span> Student(name, age));<span class="comment">//Lambda表达式缩略</span></span><br><span class="line"></span><br><span class="line">        useStudentBuilder(Student::<span class="keyword">new</span>);<span class="comment">//引用构造器方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useStudentBuilder</span><span class="params">(StudentBuilder sb)</span></span>&#123;</span><br><span class="line">        Student s = sb.build(<span class="string">&quot;王守义&quot;</span>, <span class="number">13</span>);</span><br><span class="line">        System.out.println(s.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda表达式 </tag>
            
            <tag> 函数式式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—网络编程</title>
      <link href="/2021/09/25/Java%E5%9F%BA%E7%A1%80%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/09/25/Java%E5%9F%BA%E7%A1%80%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>此部分记录了使用Java进行网络编程所使用的基本类与方法，共分为「InetAddress类、UDP通信、TCP通信」三个基础部分，并通过两个实例展示「自定键盘输入、字符缓冲流封装、反馈、从文件到文件的发送接收」展示IO流与网络编程结合的拓展使用方法。</p><span id="more"></span><h2 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h2><p>此类的主要作用是产生主机的对象，拥有如下方法：</p><p>使用时，通常不会单独用构造函数创建一个对象，而是直接使用这个静态函数当作参数</p><table><thead><tr><th align="center">方法名</th><th>类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">static InetAddress.getByName(String host)</td><td>构造函数</td><td align="center">确定主机名称的IP地址。<br />host 可以是机器名称，也可以是IP地址</td></tr><tr><td align="center">String getHostName()</td><td>方法</td><td align="center">获取此IP地址的主机名</td></tr><tr><td align="center">String getHostAddress()</td><td>方法</td><td align="center">返回文本显示中的IP地址字符串</td></tr></tbody></table><h2 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h2><p><strong>概念</strong></p><ul><li>它在通信的两端各建立一个Socket对象，没有所谓的客户端和服务器</li><li>Java提供了DatagramSocket类作为基于UDP协议的Socket</li></ul><h3 id="UDP发送数据"><a href="#UDP发送数据" class="headerlink" title="UDP发送数据"></a>UDP发送数据</h3><p><strong>构造方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DatagramSocket()</td><td align="center">创建【数据报套接字】，并将其绑定到本机地址上的任何可用端口</td></tr><tr><td align="center">DatagramPacket(byte[] buf,int len,InetAddress add,int port)</td><td align="center">创建【数据包】,发送长度为len的数据包到指定主机的指定端口</td></tr></tbody></table><p><strong>相关方法</strong></p><table><thead><tr><th align="center">对应类</th><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DatagramSocket</td><td align="center">void send(DatagramPacket p)</td><td align="center">发送数据报包</td></tr><tr><td align="center">DatagramSocket</td><td align="center">void close()</td><td align="center">关闭数据报套接字</td></tr></tbody></table><p><strong>表格描述</strong></p><p>操作中需要两个对象：</p><ul><li>发送端对象(<code>DatagramSocket</code>)：负责提供发送的方法</li><li>数据包对象(<code>DatagramPacket</code>)：负责指定数据包「内容、接收端主机对象、端口」</li></ul><table><thead><tr><th align="center">操作位置</th><th align="center">操作方式</th><th align="center">方法名/类名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">主类</td><td align="center">new</td><td align="center">DatagramSocket()</td><td align="center">创建发送端的Socket对象</td></tr><tr><td align="center">—</td><td align="center">定义</td><td align="center">byte[] bys = “xxx”.getBytes();</td><td align="center">创建数据</td></tr><tr><td align="center">—</td><td align="center">new</td><td align="center">DatagramPacket(byte[] buf,int len,InetAddress add,int port)</td><td align="center">数据打包</td></tr><tr><td align="center">—</td><td align="center">调用</td><td align="center">void send(DatagramPacket p)</td><td align="center">调用DatagramSocket对象方法发送数据</td></tr><tr><td align="center">—</td><td align="center">调用</td><td align="center">ds.close();</td><td align="center">关闭接收端</td></tr></tbody></table><p><strong>代码描述</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">    DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据，并把数据打包</span></span><br><span class="line">    <span class="keyword">byte</span>[] bys = <span class="string">&quot;Udp 示例&quot;</span>.getBytes();</span><br><span class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length, InetAddress.getByName(<span class="string">&quot;192.168.1.3&quot;</span>), <span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用DatagramSocket对象的方法发送数据</span></span><br><span class="line">    ds.send(dp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭发送端</span></span><br><span class="line">    ds.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="UDP接收数据"><a href="#UDP接收数据" class="headerlink" title="UDP接收数据"></a>UDP接收数据</h3><hr><p><strong>构造方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DatagramPacket(byte[] buf, int len)</td><td align="center">创建一个DatagramPacket用于接收长度为len的数据包</td></tr></tbody></table><p><strong>DatagramPacket相关方法</strong></p><table><thead><tr><th align="center">对应类</th><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DatagramPacket</td><td align="center">byte[] getData()</td><td align="center">返回数据缓冲区</td></tr><tr><td align="center">DatagramPacket</td><td align="center">int getLength()</td><td align="center">返回要发送的数据的长度或接收的数据的长度</td></tr><tr><td align="center">DatagramSocket</td><td align="center">void receive(DatagramPacket p)</td><td align="center">从此套接字接受数据报包给到<code>DatagramPacket</code></td></tr></tbody></table><p><strong>表格描述</strong></p><table><thead><tr><th align="center">操作位置</th><th align="center">操作方式</th><th align="center">方法名/类名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">主类</td><td align="center">new</td><td align="center">DatagramPacket(byte[] buf, int len)</td><td align="center">创建接收端的Socket对象</td></tr><tr><td align="center">—</td><td align="center">创建</td><td align="center">byte[] bys = new byte[1024];<br />DatagramPacket dp = new DatagramPacket(bys, bys.length);</td><td align="center">创建数据包，用于接收数据</td></tr><tr><td align="center">—</td><td align="center">调用</td><td align="center">ds.receive(dp);</td><td align="center">调用DatagramSocket对象的方法接收数据(上一节)</td></tr><tr><td align="center">—</td><td align="center">匿名内部类/new</td><td align="center">String new String(dp.getData(), 0,dp.getLength())</td><td align="center">解析数据</td></tr><tr><td align="center">—</td><td align="center">调用</td><td align="center">ds.close();</td><td align="center">关闭接收端</td></tr></tbody></table><p><strong>代码描述</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个【数据包】，用于接收数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">        ds.receive(dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------啰嗦写法-----------</span></span><br><span class="line">        <span class="comment">//解析【数据包】，取出【数据包】中的字节数组并把数据在控制台显示</span></span><br><span class="line">        <span class="keyword">byte</span>[] datas = dp.getData();<span class="comment">//创建一个字节数组用于接收【数据包】内的字节数组</span></span><br><span class="line">        <span class="comment">//获取实际发送数据的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = dp.getLength();</span><br><span class="line">        <span class="comment">//开始解析</span></span><br><span class="line">        String dataString = <span class="keyword">new</span> String(datas, <span class="number">0</span>, len);<span class="comment">//排除多余空字符</span></span><br><span class="line">        System.out.println(dataString);</span><br><span class="line">    <span class="comment">//---------------啰嗦写法 End-----------</span></span><br><span class="line">        <span class="comment">//简化写法：</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>,dp.getLength()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭接收端</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP通信程序"><a href="#TCP通信程序" class="headerlink" title="TCP通信程序"></a>TCP通信程序</h2><p><strong>Java中的TCP通信</strong></p><ul><li>Java使用Socket对象代表两端的通信端口，并通过<strong>Socket产生IO流</strong>来通信。</li><li>Java为客户端提供了Socket类，为服务器端提供了ServerSocket类</li></ul><h3 id="TCP发送数据"><a href="#TCP发送数据" class="headerlink" title="TCP发送数据"></a>TCP发送数据</h3><p><strong>表格描述</strong></p><table><thead><tr><th align="center">操作位置</th><th align="center">操作方式</th><th align="center">方法名/类名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">主类</td><td align="center">new</td><td align="center">Socket(String host, int port)</td><td align="center">创建客户端Socket对象</td></tr><tr><td align="center">—</td><td align="center">调用Socket方法</td><td align="center">OutputStream getOutputStream()</td><td align="center">获取输出流…</td></tr><tr><td align="center">—</td><td align="center">调用OutputStream方法</td><td align="center">void write(“TCP 示例”.getBytes())</td><td align="center">…写数据</td></tr><tr><td align="center">—</td><td align="center">调用Socket方法</td><td align="center">void close()</td><td align="center">释放资源</td></tr></tbody></table><p>※释放资源只要释放最顶层的对象，衍生的对象也会释放</p><p><strong>代码描述</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建客户端的Socket对象(Socket)</span></span><br><span class="line">        <span class="comment">//Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号</span></span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10088</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取输出流，写数据</span></span><br><span class="line">        <span class="comment">//OutputStream getOutputStream() 返回此套接字的输出流</span></span><br><span class="line">        OutputStream os = s.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;hello,tcp！！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP接收数据"><a href="#TCP接收数据" class="headerlink" title="TCP接收数据"></a>TCP接收数据</h3><p><strong>表格描述</strong></p><table><thead><tr><th align="center">操作位置</th><th align="center">操作方式</th><th align="center">方法名/类名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">主类</td><td align="center">new</td><td align="center">ServerSocket(int port)</td><td align="center">创建服务器端的Socket对象(ServerSocket)</td></tr><tr><td align="center">—</td><td align="center">调用ServerSocket方法</td><td align="center">Socket accept()</td><td align="center">侦听连接到此的套接字<br />接收成为【socket】对象</td></tr><tr><td align="center">—</td><td align="center">调用Socket方法</td><td align="center">InputStream getInputStream()</td><td align="center">获取输入流…</td></tr><tr><td align="center">—</td><td align="center">调用InputStream方法</td><td align="center">byte[] bys = new byte[1024];<br />int len = is.read(bys)</td><td align="center">…读数据…</td></tr><tr><td align="center">—</td><td align="center">new/匿名内部类</td><td align="center">String new String(bys,0,len)</td><td align="center">…数据处理</td></tr><tr><td align="center">—</td><td align="center">调用Socket与ServerSocket方法</td><td align="center">close()</td><td align="center">释放资源</td></tr></tbody></table><p>※此处「字节流读数据」不能使用while循环</p><h2 id="拓展操作实例-以TCP为例"><a href="#拓展操作实例-以TCP为例" class="headerlink" title="拓展操作实例(以TCP为例)"></a>拓展操作实例(以TCP为例)</h2><h3 id="自定键盘输入-封装字符缓冲流-发送"><a href="#自定键盘输入-封装字符缓冲流-发送" class="headerlink" title="自定键盘输入+封装字符缓冲流 发送"></a>自定键盘输入+封装字符缓冲流 发送</h3><p><strong>案例需求</strong></p><p>客户端：数据来自于键盘录入，直到输入的数据是886,发送数据结束 </p><p>服务端：接收到数据在控制台输出</p><p><strong>案例分析</strong> </p><p>客户端创建对象，使用键盘录入循环接受数据，接受一行发送一行，直到键盘录入886为止</p><p>服务端创建对象，使用输入流按行循环接受数据，直到接受到null为止</p><p><strong>代码实现</strong></p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//手寫鍵盤輸入為字符輸出流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10086</span>);</span><br><span class="line">        <span class="comment">//通信的IO流封裝字節輸出流</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(line.equals(<span class="string">&quot;886&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10086</span>);</span><br><span class="line">        Socket s = ss.accept();</span><br><span class="line">        <span class="comment">//封裝字符輸入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件到文件-反馈-多线程"><a href="#文件到文件-反馈-多线程" class="headerlink" title="文件到文件+反馈+多线程"></a>文件到文件+反馈+多线程</h3><p><strong>案例需求</strong> </p><p>客户端：数据来自于文本文件，接收服务器反馈 </p><p>服务器：接收到的数据写入文本文件，给出反馈，代码用线程进行封装，为每一个客户端开启一个线程</p><p><strong>案例分析</strong></p><p>创建客户端对象，创建输入流对象指向文件，每读入一行数据就给服务器输出一行数据，输出结束后使 用shutdownOutput()方法告知服务端传输结束 </p><p>创建多线程类，在run()方法中读取客户端发送的数据，为了防止文件重名，使用计数器给文件名编号， 接受结束后使用输出流给客户端发送反馈信息。 </p><p>创建服务端对象，每监听到一个客户端则开启一个新的线程接受数据。 客户端接受服务端的回馈信息 </p><p><strong>代码实现</strong></p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//客户端对象+字符流</span></span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10090</span>);</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件输入流对象+发送文件</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;C:\\test\\ArrayListToFileDemo.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收反馈</span></span><br><span class="line">        BufferedReader receive = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">        String receiveLine = receive.readLine();</span><br><span class="line">        System.out.println(receiveLine);</span><br><span class="line"></span><br><span class="line">        s.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收传入的对象</span></span><br><span class="line">    <span class="keyword">private</span> Socket s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排除文件重名问题</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\test\\TCPTHREAD&quot;</span> + i + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (file.exists()) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\test\\TCPTHREAD&quot;</span> + i + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//追加写入</span></span><br><span class="line">                BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>));</span><br><span class="line">                bw.write(line);</span><br><span class="line">                bw.newLine();</span><br><span class="line">                bw.flush();</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反馈</span></span><br><span class="line">            BufferedWriter back = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line">            back.write(<span class="string">&quot;接收到文件&quot;</span> + i);</span><br><span class="line">            back.newLine();</span><br><span class="line">            back.flush();</span><br><span class="line"></span><br><span class="line">            s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建服务器Socket对象</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10090</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//美接收到一个 ss.accept() 就创建并开启线程</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerThread(ss.accept())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例说明</strong></p><ul><li>线程类中：不可以在排除文件重名时创建文件，否则会一直循环。如果要创建，需要利用if去break</li><li>线程类中：之所以使用追加写入，就是为了能释放资源</li><li>服务端类中：开启线程使用的是缩略写法</li><li>此实例中如果排除“多线程”的话写法如下，可以更清晰的感知服务端的写法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//标准服务端操作(SS对象+侦听+封装)</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10000</span>);</span><br><span class="line">        Socket s = ss.accept();</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件写入封装</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\test\\TCPWriterNoTwo.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反馈</span></span><br><span class="line">        BufferedWriter back = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line">        back.write(<span class="string">&quot;接收完成&quot;</span>);</span><br><span class="line">        back.newLine();</span><br><span class="line">        back.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ss.close();</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—多线程</title>
      <link href="/2021/09/23/Java%E5%9F%BA%E7%A1%80%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/09/23/Java%E5%9F%BA%E7%A1%80%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要记录了Java中多线程的基础操作，文章结构分为「多线程的实现方法、多线程的基本操作、线程安全」三个部分以及一个「生产者与消费者模型」的实例。</p><span id="more"></span><h2 id="多线程的实现方法"><a href="#多线程的实现方法" class="headerlink" title="多线程的实现方法"></a>多线程的实现方法</h2><h3 id="方法一：继承Thread类"><a href="#方法一：继承Thread类" class="headerlink" title="方法一：继承Thread类"></a>方法一：继承Thread类</h3><p>需要：线程类 + 主类</p><p><strong>表格描述</strong></p><table><thead><tr><th align="center">操作位置</th><th align="center">操作方式</th><th align="center">方法名/类名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">线程类(MyThread)</td><td align="center">继承</td><td align="center">Thread</td><td align="center">定义一个类MyThread继承Thread类</td></tr><tr><td align="center">—</td><td align="center">重写</td><td align="center">void run()</td><td align="center">在MyThread类中重写run()方法</td></tr><tr><td align="center">主类</td><td align="center">new</td><td align="center">线程类</td><td align="center">创建MyThread类的对象</td></tr><tr><td align="center">—</td><td align="center">对象.方法</td><td align="center">void start()</td><td align="center">【启动线程】执行线程类重写的方法</td></tr></tbody></table><p><strong>代码描述</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyThread类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread my1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread my2 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 start() 方法启动线程，调 run() 方法</span></span><br><span class="line">        my1.start();</span><br><span class="line">        my2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：实现Runnable接口"><a href="#方法二：实现Runnable接口" class="headerlink" title="方法二：实现Runnable接口"></a>方法二：实现Runnable接口</h3><p>主要：线程类 + 主类</p><p><strong>表格描述</strong></p><table><thead><tr><th align="center">操作位置</th><th align="center">操作方式</th><th align="center">方法名/类名/接口名</th><th>传参</th><th align="center">说明</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">线程类(MyRunnable)</td><td align="center">实现</td><td align="center">Runnable</td><td></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">—</td><td align="center">重写</td><td align="center">void run()</td><td></td><td align="center"></td><td align="center">*需要获取<code>Thread.currentThread()</code>才能对类操作</td></tr><tr><td align="center">主类</td><td align="center">new</td><td align="center">线程类(MyRunnable)</td><td></td><td align="center">创建MyRunnable类的对象</td><td align="center"></td></tr><tr><td align="center">—</td><td align="center">new</td><td align="center">Thread类</td><td>线程类对象</td><td align="center">创建Thread类的对象，<br/>把MyRunnable对象作为构造方法的参数</td><td align="center">*多种构造方法</td></tr><tr><td align="center">—</td><td align="center">对象.方法</td><td align="center">void start()</td><td></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>Thread类构造方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Thread(Runnable target)</td><td align="center">分配一个新的Thread对象</td></tr><tr><td align="center">Thread(Runnable target, String name)</td><td align="center">分配一个新的Thread对象<br/>并给线程命名</td></tr></tbody></table><p><strong>代码描述</strong></p><p>MyRunnable类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i); <span class="comment">//要先获取当前线程类的引用【Thread.currentThread()】后才能用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyRunnable类的对象</span></span><br><span class="line">        MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Thread类的对象，把MyRunnable对象作为构造方法的参数</span></span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处</strong></p><ul><li>避免了Java单继承的局限性(Runnable 可以再继承其他类)</li><li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</li></ul><h2 id="对线程的操作"><a href="#对线程的操作" class="headerlink" title="对线程的操作"></a>对线程的操作</h2><p>主要包括：「获取/设置线程名称、线程调度、线程控制」以及特殊方法「获取当前线程对象的引用」</p><h3 id="A-获取当前线程对象的引用"><a href="#A-获取当前线程对象的引用" class="headerlink" title="A:获取当前线程对象的引用"></a>A:获取当前线程对象的引用</h3><p>因为对线程的操作需要对“Thread类的引用”操作。所以，在<strong>【Runnable类】</strong>和<strong>【主类】</strong>要对当前类操作时，需要用此方法</p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th><th>使用方法</th></tr></thead><tbody><tr><td align="center">Thread currentThread()</td><td align="center">返回对当前正在执行的线程对象的引用</td><td>Thread.currentThread().xxx</td></tr></tbody></table><p>例如：在<strong>【Runnable类】</strong>和<strong>【主类】</strong>中要获得线程名称，使用<code>Thread.currentThread().getName()</code></p><h3 id="B-设置-获取线程名称"><a href="#B-设置-获取线程名称" class="headerlink" title="B:设置/获取线程名称"></a>B:设置/获取线程名称</h3><p><strong>方法一：使用Thread类方法</strong></p><p>方法列表：</p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void setName(String name)</td><td align="center">【设置线程名字】为name</td></tr><tr><td align="center">String getName()</td><td align="center">【返回线程名称】</td></tr></tbody></table><p><strong>方法二：使用带参构造函数命名</strong></p><table><thead><tr><th>多线程实现方法</th><th>构造函数</th><th>使用示例</th></tr></thead><tbody><tr><td>继承Thread类</td><td>Thread(String name)</td><td>MyThread my = new MyThread(“小狗”);</td></tr><tr><td>实现Runnable方法</td><td>Thread(Runnable target, String name)</td><td>Thread th = new Thread(myRunnable, “小猫”);</td></tr></tbody></table><h3 id="C-线程调度"><a href="#C-线程调度" class="headerlink" title="C:线程调度"></a>C:线程调度</h3><p><strong>优先级</strong></p><p>主要靠优先级来实现，关于优先级有如下说明：</p><ul><li>默认优先级：Thread.NORM_PRIORTY     (=5)</li><li>优先级范围：Thread.MIN_PRIORTY    (=1) ~ Thread.MAX_PRIORITY    (=10)</li><li>线程优先级高代表获取线程优先级高，<em>不保证先运行</em></li></ul><p><strong>优先级操作方法：</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">final int getPriority()</td><td align="center">获取优先级</td><td align="center">tp1.getPriority()</td></tr><tr><td align="center">final void setPriority(int newPriority)</td><td align="center">设置优先级</td><td align="center">tp1.setPriority(5);</td></tr></tbody></table><h3 id="D-线程控制"><a href="#D-线程控制" class="headerlink" title="D:线程控制"></a>D:线程控制</h3><p><strong>控制方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">static void sleep(long millis)</td><td align="center">使线程停留指定的毫秒数</td><td align="center">Thread.sleep(1000);<br />*异常处理</td></tr><tr><td align="center">void join()</td><td align="center">等待此线程死亡后才能执行其他</td><td align="center">tj1.join();<br />*异常处理</td></tr><tr><td align="center">void setDaemon(boolean on)</td><td align="center">标记守护线程※</td><td align="center">td1.setDaemon(true);</td></tr></tbody></table><p><strong>控制意义</strong></p><ul><li><code>sleep()</code>：让这个线程停下来，给别的线程抢资源。让线程们大致均匀的抢资源</li><li><code>join()</code>：让这个线程死亡再执行其他，阻止其他线程抢资源</li><li><code>setDaemon(boolean on)</code>：如果只剩下守护线程，那么 <em>虚拟机就退出</em></li></ul><h2 id="线程安全——同步-synchronized"><a href="#线程安全——同步-synchronized" class="headerlink" title="线程安全——同步 synchronized"></a>线程安全——同步 synchronized</h2><p><strong>判断多线程是否会出现数据安全问题的标准</strong></p><ul><li>是否<strong>多线程</strong>环境</li><li>是否有<strong>共享数据</strong></li><li>是否有<strong>多条语句操作共享数据</strong>（含比较、更改、输出等各种操作）</li></ul><p><strong>关于锁</strong></p><p>锁是通过对象来判定的，对象是同一个，就是同一个锁，会同时锁住。</p><h3 id="A-同步代码块（给代码块加锁）"><a href="#A-同步代码块（给代码块加锁）" class="headerlink" title="A:同步代码块（给代码块加锁）"></a>A:同步代码块（给代码块加锁）</h3><p><strong>使用位置</strong></p><p>锁住“操作共享数据的多条语句”</p><p>只要同步代码块锁中传入的对象是同一个，就是同一个锁，会同时锁住</p><p><strong>使用格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();<span class="comment">//一定要在外界创建对象，一个对象就是一把锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(任意对象-obj)&#123;</span><br><span class="line">    多条语句操作共享数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-同步-成员-方法（给方法加锁）"><a href="#B-同步-成员-方法（给方法加锁）" class="headerlink" title="B:同步(成员)方法（给方法加锁）"></a>B:同步(成员)方法（给方法加锁）</h3><p><strong>使用格式</strong></p><p>分类同步方法和同步静态方法，区别就是是否有<code>static</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;<span class="keyword">static</span>&gt; <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">    多次操作的共享数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>锁的对象</strong></p><ul><li>非静态方法：<code>this</code></li><li>静态方法：<code>类名.class</code>（此方法在反射中，可以获得类）</li></ul><h3 id="C-线程安全的类【理解即可】"><a href="#C-线程安全的类【理解即可】" class="headerlink" title="C:线程安全的类【理解即可】"></a>C:线程安全的类【理解即可】</h3><h3 id="线程安全数据类型："><a href="#线程安全数据类型：" class="headerlink" title="线程安全数据类型："></a>线程安全数据类型：</h3><h4 id="StringBuffer（线程安全可变的字符序列）"><a href="#StringBuffer（线程安全可变的字符序列）" class="headerlink" title="StringBuffer（线程安全可变的字符序列）"></a>StringBuffer（线程安全可变的字符序列）</h4><ul><li>线程安全，可变的字符序列</li><li>从JDK 5开始，被StringBuilder 替代。 通常应该使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为它不执行同步</li></ul><h4 id="Vector（线程安全列表List）"><a href="#Vector（线程安全列表List）" class="headerlink" title="Vector（线程安全列表List）"></a>Vector（线程安全列表List）</h4><ul><li>从Java 2平台v1.2开始，<strong>该类改进了List接口</strong>，使其成为Java Collections Framework的成员。 与新的集合实现不同， Vector被同步。</li><li><strong>如果不需要线程安全的实现，建议使用ArrayList代替Vector</strong></li></ul><h4 id="Hashtable（线程安全Hash表）"><a href="#Hashtable（线程安全Hash表）" class="headerlink" title="Hashtable（线程安全Hash表）"></a>Hashtable（线程安全Hash表）</h4><ul><li>该类实现了一个哈希表，它将键映射到值。 任何非null对象都可以用作键或者值</li><li>从Java 2平台v1.2开始，该类进行了改进，<strong>实现了Map接口</strong>，使其成为Java Collections Framework的成员。 与新的集合实现不同， Hashtable被同步。</li><li><strong>如果不需要线程安全的实现，建议使用HashMap代替Hashtable</strong></li></ul><h3 id="使非线程安全的数据类型变成线程安全-Collections"><a href="#使非线程安全的数据类型变成线程安全-Collections" class="headerlink" title="使非线程安全的数据类型变成线程安全(Collections)"></a>使非线程安全的数据类型变成线程安全(Collections)</h3><ul><li>static List synchronizedList ( List list);</li><li>static List synchronizedSet ( Set list);</li><li>static List synchronizedMap ( Map list);</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br></pre></td></tr></table></figure><h2 id="线程安全——锁-Lock接口"><a href="#线程安全——锁-Lock接口" class="headerlink" title="线程安全——锁 Lock接口"></a>线程安全——锁 Lock接口</h2><p>使用方法请关注「代码描述」</p><p><strong>Lock说明</strong></p><ul><li>是接口，采用它的实现类ReentrantLock来实例化</li><li>比<code>synchronized</code>更广放的锁定操作</li><li>使用于线程类中</li><li>Lock 加锁解锁 要用 try{…}finally{…} 环绕，防止程序出错不能解锁</li></ul><p><strong>构造方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ReentrantLock()</td><td align="center">创建一个ReentrantLock的实例</td></tr></tbody></table><p><strong>加解锁方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void lock()</td><td align="center">加锁</td></tr><tr><td align="center">void unlock()</td><td align="center">解锁</td></tr></tbody></table><p>※Lock 加锁解锁 要用 try{…}finally{…} 环绕，防止程序出错不能解锁</p><p><strong>代码描述</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//利用 Lock 的实现类对象 创建 Lock：</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Lock 加锁解锁 要用 try&#123;...&#125;finally&#123;...&#125; 环绕，防止程序出错不能解锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//加锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><h3 id="模型概述"><a href="#模型概述" class="headerlink" title="模型概述"></a>模型概述</h3><p>是一个经典的多线程模型，提供<strong>两个线程</strong>和一个<strong>数据共享区</strong>。数据共享区的存在<strong>解耦</strong>了生产者和消费者关系。</p><p>此程序<strong>关键在于数据共享区提供的操作</strong></p><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">生产者线程</td><td align="center">生产数据</td></tr><tr><td align="center">消费者线程</td><td align="center">使用数据</td></tr><tr><td align="center">共享数据区域</td><td align="center">生产者产生的数据放入<strong>共享区域</strong>，不关心消费者使用<br />消费者从<strong>共享区域</strong>域获取数据，不关心数据生产</td></tr></tbody></table><p>示意图：</p><p><img src="file://C:/Users/railm/.config/joplin-desktop/resources/5ce77a07ee354d1383cab1b70ee76ed5.png?t=1631372335477" alt="img"></p><h3 id="等待与唤醒"><a href="#等待与唤醒" class="headerlink" title="等待与唤醒"></a>等待与唤醒</h3><p><strong>使用注意</strong></p><ul><li><code>wite()</code>与<code>notify()</code>方法，必须在同步(锁)内部使用；</li><li><code>wite()</code>之后必须要<code>notify()</code>唤醒方可继续执行;</li></ul><p><strong>方法</strong><br>来自 <code>Object类</code></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void wait()</td><td align="center">当前线程等待，直到另一个线程调用该对象唤醒（ notify()方法或notifyAll()方法）</td></tr><tr><td align="center">void notify()</td><td align="center">唤醒正在等待对象监视器的单个线程</td></tr><tr><td align="center">void notifyAll()</td><td align="center">唤醒正在等待对象监视器的所有线程</td></tr></tbody></table><h3 id="实例【生产者与消费者】"><a href="#实例【生产者与消费者】" class="headerlink" title="实例【生产者与消费者】"></a>实例【生产者与消费者】</h3><p><strong>实例指南</strong></p><p>生产者消费者案例中包含的类：</p><ol><li>奶箱类(Box)：定义一个成员变量，表示第x瓶奶，<strong>提供存储牛奶和获取牛奶的操作</strong></li><li>生产者类(Producer)：实现Runnable接口，重写run()方法，调用存储牛奶的操作</li><li>消费者类(Customer)：实现Runnable接口，重写run()方法，调用获取牛奶的操作</li><li>测试类(BoxDemo)：里面有main方法，main方法中的代码步骤如下<pre><code> A:创建奶箱对象，这是共享数据区域 B:创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作 C:创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作 D:创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递 E:启动线程</code></pre></li></ol><p><strong>代码实现</strong></p><p><strong>Box类（重点）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示第x瓶奶，提供存储牛奶和获取牛奶的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> milk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个成员变量，表示Box的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供存储牛奶和获取牛奶的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> milk)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果有奶，就等待消费</span></span><br><span class="line">        <span class="keyword">if</span>(state)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有牛奶，就生产牛奶</span></span><br><span class="line">        <span class="keyword">this</span>.milk = milk;</span><br><span class="line">        System.out.println(<span class="string">&quot;送奶工送入第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产完毕之后，修改Box状态，唤醒其他等待的线程</span></span><br><span class="line">        state = <span class="keyword">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果没奶，就等待生产</span></span><br><span class="line">        <span class="keyword">if</span>(!state)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有奶，就消费牛奶</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户拿到第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费牛奶之后，就修改Box状态,唤醒其他等待的线程</span></span><br><span class="line">        state = <span class="keyword">false</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Producer类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(Box b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">            b.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Customer类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Box b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            b.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建奶箱对象，这是共享数据区域</span></span><br><span class="line">        Box b = <span class="keyword">new</span> Box();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作</span></span><br><span class="line">        Producter producter = <span class="keyword">new</span> Producter(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</span></span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(producter);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(customer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到「海の咲的杂货铺」</title>
      <link href="/2021/09/19/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E3%80%8C%E6%B5%B7%E3%81%AE%E5%92%B2%E7%9A%84%E6%9D%82%E8%B4%A7%E9%93%BA%E3%80%8D/"/>
      <url>/2021/09/19/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E3%80%8C%E6%B5%B7%E3%81%AE%E5%92%B2%E7%9A%84%E6%9D%82%E8%B4%A7%E9%93%BA%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>你们好呀！</p><p>欢迎来到「海の咲的杂货铺」，</p><p>现在「海の咲的杂货铺」正在装修中。</p><p>我们会做足准备，</p><p>所以，</p><p>请期待正式开张的那一天吧！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
