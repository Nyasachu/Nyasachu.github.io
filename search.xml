<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot—Web·基本注解</title>
      <link href="/2021/10/06/SpringBoot%E2%80%94Web%C2%B7%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/10/06/SpringBoot%E2%80%94Web%C2%B7%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>这里给出了业务中常用的注解的使用方法。<br>涉及：@PathVariable（路径变量）、@RequestHeader（获取请求头）、@RequestParam（获取请求参数）、@CookieValue（获取cookie值）、@RequestBody（获取请求体·仅POST）、@RequestAttribute（获取request域属性）、@MatrixVariable（矩阵变量）</p><span id="more"></span><h2 id="PathVariable-路径变量"><a href="#PathVariable-路径变量" class="headerlink" title="@PathVariable 路径变量"></a>@PathVariable 路径变量</h2><table><thead><tr><th>注解名</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@PathVariable(“xxx”)</td><td>方法传参</td><td>接收 Rest风格 请求路径中<code>&#123;xxx&#125;</code> 给后面的值</td></tr><tr><td>@PathVariable Map&lt;String, String&gt;</td><td>方法传参</td><td>接收 Rest风格 请求路径中所有 {…},保存给Map</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  此时访问的URL localhost/car/2/owner/zhangsan</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">getCar</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="meta">@PathVariable(&quot;username&quot;)</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="meta">@PathVariable</span> Map&lt;String,String&gt; pv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里用Map接收传入参数，做测试之用</span></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>,id);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">        map.put(<span class="string">&quot;pv&quot;</span>,pv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>访问 <code>localhost/car/2/owner/zhangsan</code> 可将<br><code>2</code>传给<code>id</code>，<br><code>zhangsan</code>传给<code>name</code><br><code>&quot;id&quot;:&quot;2&quot;, &quot;name&quot;:&quot;zhangsan&quot;</code>传给<code>pv</code></p><h2 id="RequestHeader-请求头"><a href="#RequestHeader-请求头" class="headerlink" title="@RequestHeader 请求头"></a>@RequestHeader 请求头</h2><table><thead><tr><th>注解名</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@RequestHeader(“key”)</td><td>方法传参</td><td>获取 key 的请求头 给后面的 值</td></tr><tr><td>@RequestHeader Map&lt;String, String&gt;</td><td>方法传参</td><td>获取 key 的所有请求头,保存给Map</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  此时访问的URL localhost/car/2/owner/zhangsan</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">getCar</span><span class="params">(<span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="meta">@RequestHeader</span> Map&lt;String,String&gt; header,)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里用Map接收传入参数，做测试之用</span></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;userAgent&quot;</span>,userAgent);</span><br><span class="line">        map.put(<span class="string">&quot;headers&quot;</span>,header);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="RequestParam-请求参数"><a href="#RequestParam-请求参数" class="headerlink" title="@RequestParam 请求参数"></a>@RequestParam 请求参数</h2><p>可以获取请求参数，带请求参数的URL示例<br>?后面给参数，不同参数用&amp;连接。如果出现相同的 key 就会返回集合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL localhost/car/3/owner/lisi?age=18&amp;inters=basketball&amp;inters=game</span><br></pre></td></tr></table></figure><table><thead><tr><th>注解名</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@RequestParam(“key”)</td><td>方法传参</td><td>接收 请求参数 赋值给后面的量</td></tr><tr><td>@RequestParam Map&lt;String, String&gt;</td><td>方法传参</td><td>接收 所有请求参数 保存给Map</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//URL car/3/owner/lisi?age=18&amp;inters=basketball&amp;inters=game</span></span><br><span class="line">  ......</span><br><span class="line"><span class="meta">@RequestParam(&quot;age&quot;)</span> Integer age,</span><br><span class="line"><span class="meta">@RequestParam(&quot;inters&quot;)</span> List&lt;String&gt; inters,</span><br><span class="line"><span class="meta">@RequestParam</span> Map&lt;String,String&gt; params,</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="CookieValue-Cookie值"><a href="#CookieValue-Cookie值" class="headerlink" title="@CookieValue Cookie值"></a>@CookieValue Cookie值</h2><table><thead><tr><th>注解名</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@CookieValue(“key”) String</td><td>方法传参</td><td>接收 Cookie 中的 key 给后面的 String</td></tr><tr><td>@CookieValue Cookie</td><td>方法传参</td><td>接收 所有Cookie 给Cookie</td></tr></tbody></table><h2 id="RequestBody-请求体"><a href="#RequestBody-请求体" class="headerlink" title="@RequestBody 请求体"></a>@RequestBody 请求体</h2><p>获取Post请求的请求体</p><table><thead><tr><th>注解名</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@RequestBody(“key”)</td><td>方法传参</td><td>接收 Cookie 中的 key 给后面的参数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">postMethod</span><span class="params">(<span class="meta">@RequestBody</span> String content)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;content&quot;</span>,content);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/save&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    测试@RequestBody获取数据 <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="RequestAttribute-获取request域属性"><a href="#RequestAttribute-获取request域属性" class="headerlink" title="@RequestAttribute 获取request域属性"></a>@RequestAttribute 获取request域属性</h2><table><thead><tr><th>注解名</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@RequestAttribute(value = “kay”)</td><td>方法传参</td><td>接收请求域的值 后传</td></tr></tbody></table><p>配合使用的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>setAttribute(“key”,”value”)</td><td>设置请求域的值  (“k”,”v”)<br/>方法属于HttpServletRequest</td></tr><tr><td>getAttribute(“key”)</td><td>获取请求域的指定key的值<br/>方法属于HttpServletRequest</td></tr></tbody></table><p><strong>测试用Contrller</strong></p><p>PS：第9行 返回的<code>return &quot;forward:/success&quot;</code>将整个请求都转发了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/goto&quot;)</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">goToPage</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        request.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;成功了...&quot;</span>);<span class="comment">//设置请求域的值  (&quot;k&quot;,&quot;v&quot;)</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;code&quot;</span>,<span class="number">200</span>);<span class="comment">//设置请求域的值  (&quot;k&quot;,&quot;v&quot;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/success&quot;</span>;  <span class="comment">//转发整个请求域到  /success请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/success&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">success</span><span class="params">(<span class="meta">@RequestAttribute(value = &quot;msg&quot;)</span> String msg, //获取请求域中的 msg 的值，并传参</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="meta">@RequestAttribute(value = &quot;code&quot;)</span>Integer code,//获取请求域的 code 的值，并传参</span></span></span><br><span class="line"><span class="params"><span class="function">   </span></span></span><br><span class="line"><span class="params"><span class="function">   HttpServletRequest request)</span></span>&#123;<span class="comment">//接收HttpServletRequest 类型的参数 ，并传参</span></span><br><span class="line">        Object msg1 = request.getAttribute(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Object hello = request.getAttribute(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        Object world = request.getAttribute(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Object message = request.getAttribute(<span class="string">&quot;message&quot;</span>);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;reqMethod_msg&quot;</span>,msg1);</span><br><span class="line">        map.put(<span class="string">&quot;annotation_msg&quot;</span>,msg);</span><br><span class="line">        map.put(<span class="string">&quot;hello&quot;</span>,hello);</span><br><span class="line">        map.put(<span class="string">&quot;world&quot;</span>,world);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,message);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MatrixVariable-矩阵变量"><a href="#MatrixVariable-矩阵变量" class="headerlink" title="@MatrixVariable 矩阵变量"></a>@MatrixVariable 矩阵变量</h2><h3 id="矩阵变量的语法"><a href="#矩阵变量的语法" class="headerlink" title="矩阵变量的语法"></a>矩阵变量的语法</h3><ol><li>和请求路径之间用<code>;</code>分隔</li><li>每个不同矩阵变量的<code>key</code>之间用<code>;</code>分隔</li><li>相同<code>key</code>对应多个<code>v</code>，用逗号分隔。也可以用分号分开写同名<code>key</code></li><li>矩阵变量不作为路径变量的一部分</li><li>可以有多个路径变量绑定相同<code>key</code>的矩阵变量</li></ol><p>示例：<br><code>localhost/cars/sell;low=34;brand=byd,audi,yd</code></p><h3 id="矩阵变量使用要求"><a href="#矩阵变量使用要求" class="headerlink" title="矩阵变量使用要求"></a>矩阵变量使用要求</h3><ul><li>矩阵变量需要在SpringBoot中手动开启<ul><li>UrlPathHelper 解析路径时，removeSemicolonContent（移除分号内容）默认为true，所以默认矩阵变量就被丢弃了</li></ul></li><li>矩阵变量需要绑定在<strong>路径变量中使用</strong>，直接用会404</li></ul><h2 id="矩阵变量的用法："><a href="#矩阵变量的用法：" class="headerlink" title="矩阵变量的用法："></a>矩阵变量的用法：</h2><p><strong>注解的使用</strong></p><table><thead><tr><th>注解名</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@MatrixVariable(“key”) xxx</td><td>方法传参</td><td>接收 矩阵变量key和对应值 后传给xxx<br/>当key由多个值，返回List</td></tr><tr><td>@MatrixVariable(value = “key”,pathVar = “path”) xxx</td><td>方法传参</td><td>当路径变量有多个时，就要使用<code>pathVar</code>指定是哪一个路径变量的矩阵变量</td></tr></tbody></table><p><strong>开启矩阵变量功能</strong></p><p>有两种方法，都是在配置类完成。<br>一种是：重写路径映射规则，创建一个自定的<code>UrlPathHelper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line"><span class="comment">// 不移除 &quot;分号&quot; 后面的内容。矩阵变量功能就可以生效</span></span><br><span class="line">urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);</span><br><span class="line">configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种：重新注册一个@Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">                UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">                urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);</span><br><span class="line">                configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Controller类示例</strong><br>这里有两个路径变量，使用矩阵变量时需要指定<code>pathVar</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map <span class="title">boss</span><span class="params">(<span class="meta">@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;)</span> Integer bossAge,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="meta">@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;)</span> Integer empAge)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是测试用的</span></span><br><span class="line">      Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      map.put(<span class="string">&quot;bossAge&quot;</span>,bossAge);</span><br><span class="line">      map.put(<span class="string">&quot;empAge&quot;</span>,empAge);</span><br><span class="line">      <span class="keyword">return</span> map;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果只有一个路径变量就这么写：<br><code>@MatrixVariable(&quot;age&quot;) Integer age</code> </p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot—Web·请求映射原理</title>
      <link href="/2021/10/06/SpringBoot%E2%80%94Web%C2%B7%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86/"/>
      <url>/2021/10/06/SpringBoot%E2%80%94Web%C2%B7%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Controller中每个请求都是通过请求映射实现的，这里简单记录请求映射的基本原理。</p><span id="more"></span><h2 id="PART1"><a href="#PART1" class="headerlink" title="PART1"></a>PART1</h2><p>找到 doGet() 查看继承树，我们得到了如下的内容<br><img src="01.png" alt="01.png"></p><h2 id="PART2"><a href="#PART2" class="headerlink" title="PART2"></a>PART2</h2><p>可知SpringMVC功能分析都从 <strong>org.springframework.web.servlet.DispatcherServlet</strong> –&gt; <strong>doDispatch()</strong> 方法开始的</p><p>查看 doDispatch() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   ......略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到当前请求使用哪个Handler（Controller的方法）处理</span></span><br><span class="line">      mappedHandler = getHandler(processedRequest);</span><br></pre></td></tr></table></figure><p>这里的HandlerMapping：处理器映射。/xxx-&gt;&gt;xxxx</p><h2 id="PART3"><a href="#PART3" class="headerlink" title="PART3"></a>PART3</h2><p>我们用debug跟进发现共有5个HandlerMapping<br><img src="02.png" alt="02.png"><br>其中，RequestMappingHandlerMapping：保存了所有@RequestMapping 和handler的映射规则。这就是我们在Controlller 里面写的 @RequestMapping 注解。<br>WelcomePageHandlerMapping：完成了欢迎页的映射</p><p>程序会遍历所有编写的请求，然后将所有的请求映射都在HandlerMapping中。</p><h2 id="处理请求的流程："><a href="#处理请求的流程：" class="headerlink" title="处理请求的流程："></a>处理请求的流程：</h2><ul><li>SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 /能访问到index.html；</li><li>SpringBoot自动配置了默认 的 RequestMappingHandlerMapping</li><li>请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。<ul><li>如果有就找到这个请求对应的handler</li><li>如果没有就是下一个 HandlerMapping</li></ul></li></ul><p>PS：我们需要一些自定义的映射处理，我们也可以自己给容器中放HandlerMapping。自定义 HandlerMapping</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot—Web·Rest使用与原理</title>
      <link href="/2021/10/06/SpringBoot%E2%80%94Web%C2%B7Rest%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
      <url>/2021/10/06/SpringBoot%E2%80%94Web%C2%B7Rest%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>这里记录了Web开发中请求映射 @xxxMapping 注解的使用。在表单中通过Rest风格发送 GET、POST、PUT、DELETE 请求的方法。以及实现表单中Rest功能的 HiddenHttpMethodFilter 的原理。特别注意的是，要想在表单使用 Rest风格 发送请求，需要手动开启HiddenHttpMethodFilter。</p><p>涉及：请求映射相关：@RequestMapping、@GetMapping、@PostMapping、@DeleteMapping、@PutMapping。以及 html 中表单使用 Rest 的编写示例。</p><span id="more"></span><h1 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h1><p>接收请求处理的最先的操作是请求映射。请求映射注解格式是：<code>@xxxMapping</code><br>常用的请求映射注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span></span><br><span class="line">value = <span class="string">&quot;请求映射的值&quot;</span>  method = <span class="string">&quot;请求方法&quot;</span></span><br><span class="line"></span><br><span class="line">还有一些简化的注解可以代表不同请求方法</span><br><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/user&quot;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Rest风格用法"><a href="#Rest风格用法" class="headerlink" title="Rest风格用法"></a>Rest风格用法</h1><h2 id="Rest风格概述"><a href="#Rest风格概述" class="headerlink" title="Rest风格概述"></a>Rest风格概述</h2><p>Rest风格支持指——使用HTTP请求方式动词来表示对资源的操作，不需要改变URL路径<br>Rest风格操作方法：<br><code>/user</code> –&gt;  <code>GET-获取用户、DELETE-删除用户、PUT-修改用户、POST-保存用户</code></p><h2 id="Rest表单中的实现"><a href="#Rest表单中的实现" class="headerlink" title="Rest表单中的实现"></a>Rest表单中的实现</h2><p><strong>实现方法</strong><br>因为表单只能传入 post 和 get 请求，所以需要利用核心Filter：<code>HiddenHttpMethodFilter</code> 实现重写请求。<br>具体原理见下面的原理分析。<br><strong>用法</strong></p><ul><li><p>SpringBoot中手动开启<code>HiddenHttpMethodFilter</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启页面表单的Rest功能</span></span><br></pre></td></tr></table></figure></li><li><p>html表单中<br>GET 和 POST 请求可以直接发出；<br>DELETE 和 PUT 请求需要使用隐藏参数<br>设置：①表单 method=post，②隐藏域  _method = put</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">测试REST风格</span><br><span class="line">=============== GET &amp; POST ================</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;REST-GET 提交&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;REST-POST 提交&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">=============== DELETE &amp; PUT ================</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;REST-DELETE 提交&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;REST-PUT 提交&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Controller类测试写法：<br>写好相关方法的请求映射即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">......略</span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;GET-张三&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">saveUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;POST-张三&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@PutMapping(&quot;/user&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">putUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;PUT-张三&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@DeleteMapping(&quot;/user&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;DELETE-张三&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">......略</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用客户端工具发送请求"><a href="#使用客户端工具发送请求" class="headerlink" title="使用客户端工具发送请求"></a>使用客户端工具发送请求</h2><p>使用客户端工具，如PostMan直接发送Put、delete等方式请求，无需Filter。<br>因为可以直接发出各类请求。而拦截器只会拦截POST</p><h1 id="Rest用法原理"><a href="#Rest用法原理" class="headerlink" title="Rest用法原理"></a>Rest用法原理</h1><h2 id="为什么需要在yaml手动开启"><a href="#为什么需要在yaml手动开启" class="headerlink" title="为什么需要在yaml手动开启"></a>为什么需要在yaml手动开启</h2><p>我们看<code>OrderedHiddenHttpMethodFilter</code>源码，重点在第3行:</p><p>绑定配置中前缀 <code>spring.mvc.hiddenmethod.filter</code> 的 <code>enable</code> 参数。当这个参数是 <code>true</code> 才生效。如果没配，视为<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点：</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HiddenHttpMethodFilter-工作流程"><a href="#HiddenHttpMethodFilter-工作流程" class="headerlink" title="HiddenHttpMethodFilter 工作流程"></a>HiddenHttpMethodFilter 工作流程</h2><p>表单提交要使用REST的时候，以PUT为例：</p><ul><li>表单提交会带上_method=PUT</li><li>请求过来被HiddenHttpMethodFilter拦截</li><li>HiddenHttpMethodFilter判断请求是否正常，并且是POST<ul><li>获取到_method的值。</li><li>兼容以下请求；PUT.DELETE.PATCH</li><li>原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。</li><li>过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper的。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot—Web开发·静态资源访问及原理</title>
      <link href="/2021/10/06/SpringBoot%E2%80%94Web%E5%BC%80%E5%8F%91%C2%B7%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>/2021/10/06/SpringBoot%E2%80%94Web%E5%BC%80%E5%8F%91%C2%B7%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>这里记录了Web开发中简单的静态资源访问方法与其源码分析过程。</p><span id="more"></span><h2 id="静态资源目录"><a href="#静态资源目录" class="headerlink" title="静态资源目录"></a>静态资源目录</h2><p>这里的静态资源包含“静态资源访问目录”和“静态资源所在目录”。所有静态资源都要放到“静态资源所在目录”下才能通过路径访问。</p><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><ul><li>静态资源所在目录：<br>/static (or /public or /resources or /META-INF/resources)</li><li>静态资源访问目录 ：</li><li>当前项目根路径/ + 静态资源名 </li><li>静态资源访问原理：<br>静态映射<code>/**</code>。</li><li>静态资源访问流程：<br>请求进来，先去找Controller能否处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面<h3 id="自定路径"><a href="#自定路径" class="headerlink" title="自定路径"></a>自定路径</h3>可以做到<strong>自定义静态资源访问路径</strong> 和 <strong>自定义静态资源所在路径</strong><br>方法如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="comment">#自定义静态资源访问路径</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="comment">#自定义静态资源所在路径</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="静态资源的访问"><a href="#静态资源的访问" class="headerlink" title="静态资源的访问"></a>静态资源的访问</h3><p>我们只需要访问 <code>项目名/static-path-pattern(自定义的访问前缀)/静态资源名</code> 即可访问静态资源。<br>例如：<code>localhost:8080/res/xxx.jpg</code><br>上述地址中，<code>static-path-pattern</code>并非真实存在的目录，而是由我们自行配置的。</p><h2 id="欢迎页与Favicon"><a href="#欢迎页与Favicon" class="headerlink" title="欢迎页与Favicon"></a>欢迎页与Favicon</h2><p>欢迎页是静态资源路径下的<strong>index.html</strong>；Favicon 是静态资源路径下的<strong>Favicon.jpg</strong>(png/gif)。</p><ul><li>配置时需要遵循如下两点：<ul><li>可以配置静态资源路径。即可以配置<code>static-locations</code></li><li>不可以配置静态资源的访问前缀，否则导致 index.html不能被默认访问。即不能配<code>static-path-pattern</code></li></ul></li></ul><h1 id="静态资源配置原理"><a href="#静态资源配置原理" class="headerlink" title="静态资源配置原理"></a>静态资源配置原理</h1><h2 id="条件装配"><a href="#条件装配" class="headerlink" title="条件装配"></a>条件装配</h2><ul><li>SpringBoot启动时加载xxxxAutoConfiguration。</li><li>跟进SpringMVC功能的自动配置类 WebMvcAutoConfiguration</li></ul><p>通过观察下面的条件装配代码，我们知道了，何时会使自动配置生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处注释针对上一行 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span> </span><br><span class="line"><span class="comment">//满足：只要是Web应用就OK</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="comment">//满足：上面三个类在导包后就有了</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="comment">//关键：</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">ValidationAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="具体为容器配置内容"><a href="#具体为容器配置内容" class="headerlink" title="具体为容器配置内容"></a>具体为容器配置内容</h3><p>这里我们按照下面的顺序去分析底层原理。</p><h4 id="1、想要知道具体容器中注册了什么"><a href="#1、想要知道具体容器中注册了什么" class="headerlink" title="1、想要知道具体容器中注册了什么"></a>1、想要知道具体容器中注册了什么</h4><p>我们就要去关注 <strong><code>@EnableConfigurationProperties(xxx.class)</code></strong> 这个注解。<br>（因为，这个注解会为类进行参数绑定）</p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>通过这个代码我们知道，除了这个配置类本身，还有<code>WebMvcProperties.class</code>和<code>ResourceProperties.class</code>这两个类被<strong>绑定</strong>和<strong>注册</strong>到容器中。</p><h4 id="2、跟踪这两个类"><a href="#2、跟踪这两个类" class="headerlink" title="2、跟踪这两个类"></a>2、跟踪这两个类</h4><p>我们发现，这两个类指定的配置前缀分别为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=====WebMvcProperties.class=====</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.mvc&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line">/=====ResourceProperties.class=====</span><br><span class="line"><span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.resources&quot;,</span></span><br><span class="line"><span class="meta">    ignoreUnknownFields = false</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><p>即：配置文件中 spring.mvc  spring.resources  的参数配绑定了，这也就解释了，我们上面yaml 配置未见为何要这么写</p><h4 id="3、分析配置类"><a href="#3、分析配置类" class="headerlink" title="3、分析配置类"></a>3、分析配置类</h4><p>回到配置类本身。关注<code>public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123;...&#125;</code>的方法体，开始分析。</p><h5 id="1、构造函数-WebMvcAutoConfigurationAdapter"><a href="#1、构造函数-WebMvcAutoConfigurationAdapter" class="headerlink" title="1、构造函数 WebMvcAutoConfigurationAdapter"></a>1、构造函数 WebMvcAutoConfigurationAdapter</h5><p>我们看到<strong>配置类只有唯一带参构造函数</strong>。<br>当一个配置类只有唯一带参构造函数时，所有参数的值，都会从容器确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WebMvcAutoConfigurationAdapter</span><span class="params">(ResourceProperties resourceProperties, </span></span></span><br><span class="line"><span class="params"><span class="function">  WebMvcProperties mvcProperties, ListableBeanFactory beanFactory, </span></span></span><br><span class="line"><span class="params"><span class="function">  ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, </span></span></span><br><span class="line"><span class="params"><span class="function">  ObjectProvider&lt;WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, </span></span></span><br><span class="line"><span class="params"><span class="function">  ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, </span></span></span><br><span class="line"><span class="params"><span class="function">  ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations)</span> </span>&#123;</span><br><span class="line">    ...方法体...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上述传参的分析：</p><ul><li>ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象</li><li>WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象</li><li>ListableBeanFactory beanFactory Spring的beanFactory</li><li>HttpMessageConverters 找到所有的HttpMessageConverters</li><li>ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。=========</li><li>DispatcherServletPath</li><li>ServletRegistrationBean 给应用注册Servlet、Filter….</li></ul><h5 id="2、资源处理的默认规则"><a href="#2、资源处理的默认规则" class="headerlink" title="2、资源处理的默认规则"></a>2、资源处理的默认规则</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line"><span class="comment">//webjars的规则</span></span><br><span class="line">            <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">&quot;/webjars/**&quot;</span>)) &#123;</span><br><span class="line">customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">.addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>)</span><br><span class="line">.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PART1：</strong><br>我们看第3行的 if 判断中的<code>isAddMappings</code>。追踪后看到<br><img src="01.png" alt="01.png"><br>这里由<code>addMapings</code>决定，默认为 true。如果我们在配置文件这么写：就可以<strong>禁用所有静态资源</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">add-mappings:</span> <span class="literal">false</span>   <span class="comment"># 禁用所有静态资源规则</span></span><br></pre></td></tr></table></figure><p><strong>PART2：</strong><br>我们再看这个代码第6行：<code>Duration cachePeriod = this.resourceProperties.getCache().getPeriod();</code><br>追踪<code>getPeriod()</code>，我们看到了<br><img src="02.png" alt="02.png"><br>这里可以<strong>配置缓存策略</strong> 单位是<strong>秒</strong><br>配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cache:</span></span><br><span class="line">      <span class="attr">period:</span> <span class="number">11000</span> <span class="comment"># 缓存保存多少秒</span></span><br></pre></td></tr></table></figure><p><strong>PART3：</strong><br>再看剩下的部分：<br><img src="03.png" alt="03.png"></p><h5 id="3、欢迎页的处理规则"><a href="#3、欢迎页的处理规则" class="headerlink" title="3、欢迎页的处理规则"></a>3、欢迎页的处理规则</h5><p> HandlerMapping：处理器映射。保存了每一个Handler能处理哪些请求。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HandlerMapping：处理器映射。保存了每一个Handler能处理哪些请求。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext,</span></span></span><br><span class="line"><span class="params"><span class="function">FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>&#123;</span><br><span class="line">WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="keyword">new</span> WelcomePageHandlerMapping(</span><br><span class="line"><span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),</span><br><span class="line"><span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));</span><br><span class="line">welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line"><span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>追踪<code>WelcomePageHandlerMapping</code>返回值类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,</span><br><span class="line">ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123;</span><br><span class="line"><span class="keyword">if</span> (welcomePage.isPresent() &amp;&amp; <span class="string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123;</span><br><span class="line">           <span class="comment">//要用欢迎页功能，必须是/**</span></span><br><span class="line">logger.info(<span class="string">&quot;Adding welcome page: &quot;</span> + welcomePage.get());</span><br><span class="line">setRootViewName(<span class="string">&quot;forward:index.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;</span><br><span class="line">           <span class="comment">// 调用Controller  /index</span></span><br><span class="line">logger.info(<span class="string">&quot;Adding welcome page template: index&quot;</span>);</span><br><span class="line">setRootViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现要想使用静态欢迎页，必须满足：<br>“welcomePage.isPresent() 欢迎页存在” 和 “staticPathPattern 必须是 /** ”</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><h3 id="静态配置方法"><a href="#静态配置方法" class="headerlink" title="静态配置方法"></a>静态配置方法</h3><p>本文涉及的静态配置方法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="comment">#指定静态资源访问路径前缀</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span>   <span class="comment">#这个会导致welcome page功能失效</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="comment">#指定静态资源路径</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br><span class="line">  <span class="comment">#是否禁用静态资源</span></span><br><span class="line">    <span class="attr">add-mappings:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">cache:</span></span><br><span class="line">      <span class="comment">#指定缓存时间</span></span><br><span class="line">      <span class="attr">period:</span> <span class="number">11000</span></span><br></pre></td></tr></table></figure><h3 id="本次使用的源码分析方法总结"><a href="#本次使用的源码分析方法总结" class="headerlink" title="本次使用的源码分析方法总结"></a>本次使用的源码分析方法总结</h3><ol><li>关注 <strong>@EnableConfigurationProperties(xxx.class)</strong> ：了解那些类被绑定并注入容器</li><li>跟进上述类，看 <strong>@ConfigurationProperties(prefix = “spring.mvc”)</strong> 了解配置文件绑定前缀</li><li>看 配置类方法 的 <strong>if(…){…}语句</strong> 了解是否可以禁用某些功能</li><li>追 配置类方法 的 <strong>get(…)方法</strong> –&gt; <strong>return 返回值</strong> –&gt; <strong>同类搜索关键词</strong> 了解某些值的初始赋值 和 配置方法</li><li>有时，也可以利用 提示功能 ，先配 yaml 对应参数 再从 yaml 的 参数反向追踪源码，了解底层原理</li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot—使用YAML进行配置绑定</title>
      <link href="/2021/10/05/SpringBoot%E2%80%94%E4%BD%BF%E7%94%A8YAML%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A/"/>
      <url>/2021/10/05/SpringBoot%E2%80%94%E4%BD%BF%E7%94%A8YAML%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>YAML文件非常适合用来做以数据为中心的配置文件，会在SpringBoot开发中经常是用。这里记录了YAML的基本语法，以及使用yaml进行配置绑定的方法。</p><span id="more"></span><h2 id="YAML基本语法"><a href="#YAML基本语法" class="headerlink" title="YAML基本语法"></a>YAML基本语法</h2><ul><li>key: value；kv之间有空格</li><li>大小写敏感</li><li>使用<strong>缩进</strong>表示层级关系</li><li>缩进不允许使用tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素<strong>左对齐</strong>即可</li><li> ‘#’表示注释</li><li>  字符串无需加引号，如果要加，’’与””表示字符串内容 会被 转义/不转义</li></ul><h2 id="YAML数据类型写法"><a href="#YAML数据类型写法" class="headerlink" title="YAML数据类型写法"></a>YAML数据类型写法</h2><h3 id="字面量："><a href="#字面量：" class="headerlink" title="字面量："></a>字面量：</h3><p>字面量指：单个的、不可再分的值。如：date、boolean、String、number、null</p><ul><li>关于String 中的引号：<ul><li>通常字符串不用加引号</li><li>单引号会将 \n作为字符串输出（取消原有转义符 \）</li><li>双引号会将\n 作为换行输出（保持原有转义符号 \）</li></ul></li></ul><p><strong>写法</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">k:</span> <span class="string">v</span></span><br><span class="line"><span class="comment">#关于String 的引号，如：</span></span><br><span class="line"><span class="attr">key:</span> <span class="string">&quot;line \n line&quot;</span></span><br><span class="line"><span class="comment">#  单引号会将 \n作为字符串输出   双引号会将\n 作为换行输出</span></span><br><span class="line"><span class="comment">#  双引号可以转义，单引号不会转义</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong><br>Bean类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> Boolean boss;</span><br><span class="line"><span class="keyword">private</span> Date birth;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Yaml配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">userName:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2019</span><span class="string">/12/12</span> <span class="number">20</span><span class="string">:12:33</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><h3 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h3><p>对象包括：对象和键值对的集合。如：map、hash、set、object </p><p><strong>写法</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">行内写法：</span>  <span class="attr">k:</span> &#123;<span class="string">k1:v1</span>,<span class="string">k2:v2</span>,<span class="string">k3:v3</span>&#125;</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="attr">k:</span> </span><br><span class="line">  <span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">k2:</span> <span class="string">v2</span></span><br><span class="line">  <span class="attr">k3:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong><br>Bean类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">=========Person类==========</span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Pet pet;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========Pet类==========</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Yaml配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="comment">#分行写法</span></span><br><span class="line">  <span class="attr">pet:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">阿狗</span></span><br><span class="line">    <span class="attr">weight:</span> <span class="number">99.99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#行内写法</span></span><br><span class="line">  <span class="attr">score:</span> &#123;<span class="attr">english:</span> <span class="number">98</span>,<span class="attr">math:</span> <span class="number">89</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组指：一组按次序排列的值。如：array、list、queue</p><p><strong>写法</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">行内写法：</span>  <span class="attr">k:</span> [<span class="string">v1</span>,<span class="string">v2</span>,<span class="string">v3</span>]</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="attr">k:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v2</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong><br>Bean类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">=========Person类==========</span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String[] interests;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;Pet&gt;&gt; allPets;</span><br><span class="line"></span><br><span class="line">=========Pet类==========</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Yaml配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="comment">#行内写法</span></span><br><span class="line">  <span class="attr">interests:</span> [<span class="string">篮球</span>,<span class="string">足球</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#分行写法(综合)</span></span><br><span class="line">  <span class="attr">allPets:</span></span><br><span class="line">    <span class="comment">#数组 分行写法</span></span><br><span class="line">    <span class="attr">sick:</span></span><br><span class="line">      <span class="comment">#对象 分行写法</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">阿猫</span></span><br><span class="line">        <span class="attr">weight:</span> <span class="number">16.66</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">阿狗</span></span><br><span class="line">        <span class="attr">weight:</span> <span class="number">19.99</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="comment">#对象 行内写法</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">阿花</span>,<span class="attr">weight:</span> <span class="number">199.99</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">阿明</span>,<span class="attr">weight:</span> <span class="number">199.99</span>&#125; </span><br></pre></td></tr></table></figure><h2 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h2><p>在实际编程时，我们需要将yaml文件和bean类实现配置绑定。绑定方法的实现与 所述方法相同，需要使用<code>@ConfigurationProperties(prefix = &quot;xxx&quot;)</code>的注解。<br>yaml配置文件创建在<code>sources</code>目录下的<code>application.yaml</code>.</p><h2 id="配置注解处理器"><a href="#配置注解处理器" class="headerlink" title="配置注解处理器"></a>配置注解处理器</h2><p>自定义的类和配置文件绑定一般没有提示。需要在<code>pom.xml</code>引入“SpringBoot配置注解处理器”<br>参考文档：<a href="https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/html/appendix-configuration-metadata.html#configuration-metadata-annotation-processor">https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/html/appendix-configuration-metadata.html#configuration-metadata-annotation-processor</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为这个配置注解处理器只是为了方便编程，实际业务不需要，所以打包时要给予排除。参考上述文档，排除方式是在<code>spring-boot-maven-plugin</code>中加入排除的配置。<br>加入后配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 就是这一段在排除“配置注解处理器” --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- over --&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot—Spring Initailizr 项目创建</title>
      <link href="/2021/10/05/SpringBoot%E2%80%94Spring%20Initailizr%20%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"/>
      <url>/2021/10/05/SpringBoot%E2%80%94Spring%20Initailizr%20%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>IDEA提供 Spring Initailizr （项目初始化向导）来方便我们创建 SpringBoot 项目，但是在使用过程中依然可能会遇到一些问题。<br>这里记录了通过 Spring Initailizr 创建项目的方式、创建低版本SpringBoot 项目的方法，以及找不到 Spring Initailizr 创建选项时的解决方法。</p><span id="more"></span><h2 id="Spring-Initailizr-创建项目的一般方法"><a href="#Spring-Initailizr-创建项目的一般方法" class="headerlink" title="Spring Initailizr 创建项目的一般方法"></a>Spring Initailizr 创建项目的一般方法</h2><p><strong>功能</strong><br>在创建项目时，不在需要选择创建Maven项目，而是通过这个向导创建。可以简化创建过程。</p><p><strong>使用方法</strong></p><ol><li><p>选择创建 Spring Initailizr 项目填写信息<br><img src="01.png" alt="01.png"></p></li><li><p> 选择需要的开发场景<br><img src="02.png" alt="02.png"></p></li><li><p>等待项目生成<br>IDEA会「自动依赖引入、自动创建项目结构、自动编写好主配置类」</p></li></ol><h2 id="创建低版本SpringBoot项目"><a href="#创建低版本SpringBoot项目" class="headerlink" title="创建低版本SpringBoot项目"></a>创建低版本SpringBoot项目</h2><p>（此方法似乎已经失效）</p><p>创建项目时发现，IDEA只能选择一些新的版本的SpringBoot。我们可以遵循下述方法给SpringBoot“降级”：</p><ol><li><p>任意选择创建一个版本，等待项目文件构建完成.。</p></li><li><p>在<code>pom.xml</code>中注释掉单元测试(<code>spring-boot-starter-test</code>)部分的<code>dependency</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- 注释单元测试部分的dependency后修改版本 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;scope&gt;test&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>&lt;parent&gt;</code>中修改版本号，点击maven导入</p></li><li><p>释放单元测试部分注释</p></li></ol><h2 id="找不到-Spring-Initailizr-选项的原因"><a href="#找不到-Spring-Initailizr-选项的原因" class="headerlink" title="找不到 Spring Initailizr 选项的原因"></a>找不到 Spring Initailizr 选项的原因</h2><p>Spring Initailizr 仅针对 IDEA Ultimate 版本提供，并不对 IDEA 社区版 提供。<br>如果你使用 IDEA 2020.3 版本或更旧的版本，可以使用 intellij-spring-assistant 插件实现这个功能。请参考 <a href="https://github.com/eltonsandre/intellij-spring-assistant">https://github.com/eltonsandre/intellij-spring-assistant</a><br>如果使用更新版本，推荐安装 IDEA Ultimate 版本，学生或教师可以在 <a href="https://www.jetbrains.com/zh-cn/community/education/#students">https://www.jetbrains.com/zh-cn/community/education/#students</a> 申请免费许可证。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot—实践流程与技巧</title>
      <link href="/2021/10/05/SpringBoot%E2%80%94%E5%AE%9E%E8%B7%B5%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%8A%80%E5%B7%A7/"/>
      <url>/2021/10/05/SpringBoot%E2%80%94%E5%AE%9E%E8%B7%B5%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot的优势在于避免了Spring的大量的配置，简化了开发流程。本文记录了在实际开发中我们应该关注的开发流程与小技巧。<br>涉及：Lombok 插件使用、dev-tools</p><span id="more"></span><h2 id="SpringBoot实践流程"><a href="#SpringBoot实践流程" class="headerlink" title="SpringBoot实践流程"></a>SpringBoot实践流程</h2><ul><li>引入场景依赖<ul><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</a></li></ul></li><li>查看自动配置了哪些（选做）<ul><li>自己分析，引入场景对应的自动配置一般都生效了</li><li>配置文件中debug=true开启自动配置报告。Negative（不生效）\Positive（生效）</li></ul></li><li>是否需要修改<ul><li>参照文档修改配置项（<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties%EF%BC%89">https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties）</a></li><li>自己分析。xxxxProperties绑定了配置文件的哪些。</li></ul></li><li>自定义加入或者替换组件<ul><li>@Bean、@Component。。。</li></ul></li><li>自定义器  XXXXXCustomizer；</li></ul><p>……</p><h2 id="开发小技巧"><a href="#开发小技巧" class="headerlink" title="开发小技巧"></a>开发小技巧</h2><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p><strong>功能</strong><br>简化JavaBean开发，可以避免在bean类中写 get/set/ 等方法，也可以在业务类中输出日志。<br><strong>使用方法</strong></p><ol><li><p>引入插件；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>安装插件；<br> idea中搜索<code>Lombok</code>并安装</p></li><li><p>使用lombok提供的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">=================Bean类中===================</span><br><span class="line"><span class="meta">@Data</span> ： 注在类上，提供类的get、set、equals、hashCode、canEqual、toString方法</span><br><span class="line"><span class="meta">@Setter</span> ： 注在属性上，提供 set 方法（<span class="meta">@Data</span>包含）</span><br><span class="line"><span class="meta">@Getter</span> ： 注在属性上，提供 get 方法（<span class="meta">@Data</span>包含）</span><br><span class="line"><span class="meta">@EqualsAndHashCode</span> ： 注在类上，提供对应的 equals 和 hashCode 方法（<span class="meta">@Data</span>包含）</span><br><span class="line"><span class="meta">@AllArgsConstructor</span> ： 注在类上，提供类的全参构造</span><br><span class="line"><span class="meta">@NoArgsConstructor</span> ： 注在类上，提供类的无参构造</span><br><span class="line"></span><br><span class="line">=================业务类中===================</span><br><span class="line"><span class="meta">@Log4j</span>/<span class="meta">@Slf4j</span> ： 注在类上，提供对应的 Logger 对象，变量名为 log</span><br><span class="line">使用时，在需要输出日志的位置：</span><br><span class="line">Log.info(<span class="string">&quot;这里输出日志 info&quot;</span>); <span class="comment">//error等 也可以</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="dev-tools"><a href="#dev-tools" class="headerlink" title="dev-tools"></a>dev-tools</h3><p><strong>作用</strong><br>热更新，但事实上还是自动重启（Restart），只是在静态页面变更下，并不会自动重启，而是“热更新”。<br><strong>使用方法</strong></p><ol><li>引入插件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用<br>修改代码后，点击“构建项目”或者<code>Ctrl + F9</code>。</li></ol><p><strong>说明</strong><br>这里所说的热更新，其实还是一个自动重启（Restart），只是在静态页面下，不会通过自动重启实现。<br>如果想实现正真意义上的热更新（Reload），需要使用付费插件<strong>JRebel</strong></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot—XML配置文件引入与配置绑定</title>
      <link href="/2021/10/04/SpringBoot%E2%80%94XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A/"/>
      <url>/2021/10/04/SpringBoot%E2%80%94XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot中除了可以使用配置类来实现组件注册还可以使用传统的配置文件方式来实现。<br>本文将记录配置文件引入和配置绑定实现组件注册的方法与基本原理。<br>涉及注解：@ImportResouce，@Component、@ConfigurationProperties、@EnableConfigurationProperties、@Autowired</p><span id="more"></span><h2 id="xml配置文件引入-ImportResouce"><a href="#xml配置文件引入-ImportResouce" class="headerlink" title="xml配置文件引入(@ImportResouce)"></a>xml配置文件引入(@ImportResouce)</h2><p> 传统的Spring框架下，我们需要通过xml文件来配置组件并注册，SpringBoot框架中，我们只需要通过在<strong>配置类</strong>设定<code>@ImportResouce()</code>注解即可实现引入xml配置。<br>使用方式如表</p><table><thead><tr><th>注解名</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@ImportResouce(“路径名”)</td><td>配置类开头</td><td>引入xml配置<br/>注册组件</td></tr></tbody></table><p>示例如下：<br>beans.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.boot.bean.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hehe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.boot.bean.Pet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tomcat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h2><p>我们习惯于将需要改变的参数配到配置文件，SpringBoot提供了几个注解可以帮助我们快速实现<strong>将application.properties的配置绑定</strong>。实现方法分为两种。</p><h3 id="方法一：-EnableConfigurationProperties-ConfigurationProperties"><a href="#方法一：-EnableConfigurationProperties-ConfigurationProperties" class="headerlink" title="方法一：@EnableConfigurationProperties + @ConfigurationProperties"></a>方法一：@EnableConfigurationProperties + @ConfigurationProperties</h3><p>这两个注解的使用方法：</p><table><thead><tr><th>注解名</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@ConfigurationProperties(prefix = “配置前缀”)</td><td>类</td><td>从properties引入”配置前缀”的参数</td></tr><tr><td>@EnableConfigurationProperties(类名.class)</td><td>配置类</td><td>1、开启该”类名”的properation配置绑定<br/>2、注册组件到容器</td></tr><tr><td>@Autowired</td><td>业务类</td><td>给组件属性赋值</td></tr><tr><td>※此方式创建的组件名为：<code>“类之前缀”-全类名.“类名”</code></td><td></td><td></td></tr></tbody></table><p>示例：<br>Car类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;car&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"><span class="comment">//get set 构造函数 等等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigerationPropties(Car.class)</span></span><br></pre></td></tr></table></figure><p>配置文件,application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">youcar.name</span> = <span class="string">BYD</span></span><br><span class="line"><span class="meta">youcar.price</span> = <span class="string">1000</span></span><br></pre></td></tr></table></figure><p>测试 Contraller 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span><span class="comment">//自动装配</span></span><br><span class="line">    Car car;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/car&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">handle01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：-Component-ConfigurationProperties"><a href="#方法二：-Component-ConfigurationProperties" class="headerlink" title="方法二：@Component + @ConfigurationProperties"></a>方法二：@Component + @ConfigurationProperties</h3><p>第二个注解用法遇上一个相同，这里 给出第一个用法：</p><table><thead><tr><th>注解名</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>类</td><td>注册POJO进入容器</td></tr></tbody></table><p>※此方式创建的组件名：类名首字母小写</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>上述两种方法 <code>@Component</code> 或 <code>@EnableConfigerationProperties(xxx.class)</code> 必须要有一个，用于注册组件</li><li><code>@@ConfigurationProperties(prefix = &quot;xxx&quot;)</code>，在配置文件“application.properties”</li><li>业务类需要使用<code>@Autowired</code>实现自动装配属性</li><li>方法选用：看第三方包是否有<code>@Component</code>如果没有，只能用方法一</li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot入门 </tag>
            
            <tag> SpringBoot容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot—自动配置原理与自定义配置</title>
      <link href="/2021/10/04/SpringBoot%E2%80%94%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/10/04/SpringBoot%E2%80%94%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>自动配置遵循“自动配置，按需启用”的工作方式。这部分通过源码分析，记录了自动配置的实现原理。<br>同时也通过源码阐述如何修改默认配置。</p><span id="more"></span><h2 id="初始加载自动配置类"><a href="#初始加载自动配置类" class="headerlink" title="初始加载自动配置类"></a>初始加载自动配置类</h2><p>自动配置类的初始加载是由<strong>组合注解</strong><code>@SpringBootApplication</code>实现的。前面的日志提到过，这个组合注解时由如下三个注解组成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span> </span><br></pre></td></tr></table></figure><p>下面逐个解释每个注解</p><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>追踪后发现本质是一个<code>@Configuration</code>。说明此注解表示<strong>主类也是一个配置类</strong>，是核心配置类。</p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>指定包扫描路径</p><h3 id="EnableAutoConfiguration（重点）"><a href="#EnableAutoConfiguration（重点）" class="headerlink" title="@EnableAutoConfiguration（重点）"></a>@EnableAutoConfiguration（重点）</h3><p>追踪可发现，这是由两者注解合成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure><p>下面分开说明</p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>自动配置包<br>追踪源码发现重点在于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br></pre></td></tr></table></figure><p>再次追踪<code>Registrar</code>发现下述代码与之有关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">      Registrar() &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重要部分是下面这个方法 */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">          AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line"><span class="comment">//【断点】上一行代码</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对上述代码打断点（断点位置见注释）后分析其作用：</p><ol><li>【断点】处发现，<code>metadata</code>提供了当前类的<strong>全包名</strong>(和其他信息)，然后通过<code>.getPackageNames()</code>的方法获取<strong>包名</strong>，并转成字符串数组。</li><li>这个字符串数组被传给<code>register</code>方法，由<code>register</code>方法将该包下的组件批量注册</li></ol><h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h4><p>追踪<code>AutoConfigurationImportSelector</code>。截取其中有关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line"><span class="comment">//重点在上一行</span></span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码的核心是<code>getAutoConfigurationEntry(annotationMetadata)</code>。由他获取所有需要导入的组件。追踪这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.<span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重点在下一行 */</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"><span class="comment">/* 重点在上一行 */</span></span><br><span class="line"></span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="keyword">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现重点在于<code>getCandidateConfigurations(annotationMetadata, attributes)</code>。<br>对此处断点Debug运行，<strong>发现这里获得了127个组件</strong><br>跟踪<code>getCandidateConfigurations</code>得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重点在下行 */</span></span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line"><span class="comment">/* 重点在上行 */</span></span><br><span class="line"></span><br><span class="line">        Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现这里使用<code>loadFactoryNames</code>这个工厂加载器加载了某些名字，再追踪</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryTypeName = factoryType.getName();</span><br><span class="line">    <span class="keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>追踪返回值有关的方法<code>loadSpringFactories</code>，得到如下一个有用的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br></pre></td></tr></table></figure><p>去外部库里面找 “<strong>ETA-INF/spring.factories</strong>” 目录。我们发现 <strong>ring-boot-autoconfigure-2.3.4.RELEASE.jar</strong> 库下面有这个文件。里面也看到了那 127个组件。<br>说明这个方法是将写死的127个场景进行加载。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上述两个注解，共同完成了组件的加载。分别作用如下</p><ul><li><p>@AutoConfigurationPackage</p><ul><li>利用<code>register</code>，将Main程序所在包下所有的包导入</li></ul></li><li><p>@Import(AutoConfigurationImportSelector.class)</p><ul><li>利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件</li><li>调用List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类</li><li>利用工厂加载 Map&lt;String, List<String>&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；得到所有的组件</li><li>从META-INF/spring.factories位置来加载一个文件。（默认扫描所有包的目录，spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF/spring.factories）</li></ul></li></ul><h1 id="按需启用自动配置项"><a href="#按需启用自动配置项" class="headerlink" title="按需启用自动配置项"></a>按需启用自动配置项</h1><p>上一节中提到的“127个场景”的所有自动配置启动的时候默认全部加载（利用：xxxxAutoConfiguration）。<br>但是这些场景的配置并不会都启用并注册组件。这是通过<code>jorg.springframework.boot.autoconfigure</code>目录下所展示的各个包配置文件中的条件装配规则（@Conditional）确定的。最终这些场景会按需配置。</p><h1 id="修改默认配置"><a href="#修改默认配置" class="headerlink" title="修改默认配置"></a>修改默认配置</h1><p>我们有两种方法修改默认配置，一种是在配置类自己写该组件的<code>@Bean</code>，场景加载时，通过条件装配发现用户自写相关组件就会采用用户的组件。这是由<code>@ConditionalMissingBean</code>标签实现。<br>另一种方法是用户去看这个组件是获取的配置文件什么值就去修改“application.properties”</p><h1 id="自动加载流程"><a href="#自动加载流程" class="headerlink" title="自动加载流程"></a>自动加载流程</h1><ul><li>SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration</li><li>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定</li><li>生效的配置类就会给容器中装配很多组件</li><li>只要容器中有这些组件，相当于这些功能就有了</li><li>定制化配置<ul><li>用户直接自己@Bean替换底层的组件</li><li>用户去看这个组件是获取的配置文件什么值就去修改。</li></ul></li></ul><p><strong>xxxxxAutoConfiguration —&gt; 组件  —&gt; xxxxProperties里面拿值  —-&gt; application.properties</strong></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot入门 </tag>
            
            <tag> SpringBoot容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot—容器中组件注册</title>
      <link href="/2021/10/02/SpringBoot%E2%80%94%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/"/>
      <url>/2021/10/02/SpringBoot%E2%80%94%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>这里讲述了SpringBoot的容器功能的组件添加，包括「配置类、Full模式与Lite模式、条件装配与测试类」</p><span id="more"></span><h2 id="配置类概述-Configuration"><a href="#配置类概述-Configuration" class="headerlink" title="配置类概述(@Configuration)"></a>配置类概述(@Configuration)</h2><p><code>@Configuration</code>写在类上，用于标记这是“配置类”。配置类方法中用<code>@Bean</code>注册组件，<strong>配置类本身也是组件</strong>。<br>PS：配置类相当于曾经的配置文件</p><h2 id="Full模式与Lite模式"><a href="#Full模式与Lite模式" class="headerlink" title="Full模式与Lite模式"></a>Full模式与Lite模式</h2><p>该标签可以有参数<code>@Configuration(proxyBeanMethods = true/false)</code>用于控制是否为“代理组件方法”。二者区别</p><ul><li>Lite模式：<br>【保证每个@Bean方法被调用多少次返回的组件都是单实例的】，用于【配置类组件之间无依赖关系】</li><li>Full模式：<br>【每个@Bean方法被调用多少次返回的组件都是新创建的】用于【配置类组件之间有依赖关系】<h2 id="组件注册-Bean"><a href="#组件注册-Bean" class="headerlink" title="组件注册(@Bean)"></a>组件注册(@Bean)</h2>配置类里面使用@Bean标注在方法上给容器注册组件，默认是单实例的。</li></ul><p>注册时，默认以<strong>方法名 = 组件id</strong>，<strong>返回类型 = 组件类型</strong>，<strong>返回的值 = 组件在容器中的实例</strong><br><strong>自定义组件名</strong>：如果在<code>@Bean(&quot;name&quot;)</code>则组件名(组件ID)就设定为name</p><p>配置类示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*已经有了User类和Pet类，位于`com.xxx.xxx.boot.bean`包下*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//配置类 lite模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件：lite模式下，这是一个全新的组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom&quot;)</span><span class="comment">//定义组件名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件注册-Import"><a href="#组件注册-Import" class="headerlink" title="组件注册(@Import)"></a>组件注册(@Import)</h2><p><code>@Configuration</code>使用<code>@Import(&#123;构造器, 构造器&#125;)</code>的方式也可以注册对应类型的组件，此时组件名为“<strong>全类名</strong>”<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*写在类之前*/</span></span><br><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="条件装配-Conditional"><a href="#条件装配-Conditional" class="headerlink" title="条件装配(@Conditional)"></a>条件装配(@Conditional)</h2><p>这个注解的意思是，只有满足给定条件，对应代码才生效。十分常用的功能。<br>打开<code>@Conditional</code>的依赖树，看以看到很多子注解<br><img src="01.png" alt="各种条件装配"></p><p>下面以<code>@ConditionalOnBean</code>为例展示用法(示例上上一个大体相同，只是加了注解和**@Import**):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*已经有了User类和Pet类，位于`com.xxx.xxx.boot.bean`包下*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//配置类 lite模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnBean(name = &quot;com.atguigu.boot.bean.User&quot;)</span></span><br><span class="line"><span class="comment">// 条件装配注解，如果容器有name=com.atguigu.boot.bean.User的组件这个user01 组件才注册代码才生效</span></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件：lite模式下，这是一个全新的组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom&quot;)</span><span class="comment">//定义组件名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试类的写法"><a href="#测试类的写法" class="headerlink" title="测试类的写法"></a>测试类的写法</h2><p>在主函数写测试类，对应上述示例。测试类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、返回IOC容器</span></span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">//2、遍历容器里的组件</span></span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">//3、从容器中获取组件 getBean(组件名, 类型)</span></span><br><span class="line">        Pet tom1 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line">        Pet tom2 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"><span class="comment">//这里判断了在 full 和 lite 下，组件是非时同一个</span></span><br><span class="line">        System.out.println(<span class="string">&quot;组件&quot;</span> + (tom1 == tom2));</span><br><span class="line"><span class="comment">//这里证明了 “Configuration也是一个组件”</span></span><br><span class="line">System.out.println(run.getBean(MyConfig.class));</span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">//4、从容器中获取组件名 getBeanNamesForType(类型)</span></span><br><span class="line">        String[] beanNamesForType = run.getBeanNamesForType(User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;=========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : beanNamesForType) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">//5、组件存在判断（条件装配） containsBean(&quot;name&quot;)</span></span><br><span class="line">        <span class="keyword">boolean</span> tom = run.containsBean(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;tom:&quot;</span>+tom);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> user01 = run.containsBean(<span class="string">&quot;user01&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user01:&quot;</span>+user01);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> tom22 = run.containsBean(<span class="string">&quot;tom22&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;tom22:&quot;</span> + tom22);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中使用的方法：</p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</td><td align="center">【标准写法】返回IOC容器</td></tr><tr><td align="center">String[] run.getBeanDefinitionNames()</td><td align="center">返回容器中所有组件名的String数组</td></tr><tr><td align="center">String[] run.getBeanNamesForType(xxx.class)</td><td align="center">返回容器所有“给定类型”的组件名String数组</td></tr><tr><td align="center">类型 run.getBean(组件名, 类型)</td><td align="center">返回对应组件名与类型的组件</td></tr><tr><td align="center">boolean run.containsBean(“组件名”)</td><td align="center">返回容器是否存在对应名字的组件</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot入门 </tag>
            
            <tag> SpringBoot容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot—依赖管理、starter导入与包结构</title>
      <link href="/2021/10/02/SpringBoot2%E2%80%94%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E3%80%81starter%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%8C%85%E7%BB%93%E6%9E%84/"/>
      <url>/2021/10/02/SpringBoot2%E2%80%94%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E3%80%81starter%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%8C%85%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>本文简单说明SpringBoot中的<strong>依赖管理</strong>、<strong>starter</strong>的作用与导入、<strong>包结构与扫描路径</strong>。其中讲述了复合注解<code>@SpringBootApplication</code>的展开</p><span id="more"></span><h2 id="1-依赖管理与starter导入"><a href="#1-依赖管理与starter导入" class="headerlink" title="1.依赖管理与starter导入"></a>1.依赖管理与starter导入</h2><h3 id="父项目依赖管理"><a href="#父项目依赖管理" class="headerlink" title="父项目依赖管理"></a>父项目依赖管理</h3><p>Spring Boot 使用 pom.xml 中的<strong>父项目做依赖(dependencies)管理</strong> (即：版本控制)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>跟进 pom.xml 中的<code>spring-boot-starter-parent</code>，会看到这个父项目还有一个父项目<code>spring-boot-dependencies</code>。跟进这个项目，可以看到各个常用依赖的具体版本，和依赖本身。<br>这个机制叫做——自动版本仲裁</p><h3 id="starter场景启动器"><a href="#starter场景启动器" class="headerlink" title="starter场景启动器"></a>starter场景启动器</h3><p>Starters 是一组方便的依赖描述符，只要导入starters就可以自动导入这个场景下所需的依赖项。<br>命名方式上，官方srarter(场景启动器)使用<code>spring-boot-starter-*</code>格式命名，第三方starter使用<code>*-spring-boot-starter</code>格式命名。这里的<code>*</code>就代表一种场景。<br>我们可以在<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">官方文档</a>查询所有的官方starter 。<br>所有场景启动器最底层的依赖是<code>spring-boot-starter-parent</code></p><h3 id="导入starter"><a href="#导入starter" class="headerlink" title="导入starter"></a>导入starter</h3><p>如果你要导入一个场景的依赖，那么就可以在文档中找到这个场景的starter。然后写入到 pom.xml 的<code>&lt;dependencies&gt;</code>标签。<br>你也可以找到对应场景启动器在<code>spring-boot-dependencies</code>中的<code>&lt;dependency&gt;</code>标签。复制<code>&lt;dependency&gt;</code>标签内容并粘贴在 pom.xml 。<br>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖库的版本"><a href="#依赖库的版本" class="headerlink" title="依赖库的版本"></a>依赖库的版本</h3><p>导入starter时，这些依赖的版本有两种控制方法——<strong>自动版本仲裁</strong>和<strong>手动指定</strong></p><ol><li><strong>自动版本仲裁</strong>：如果导入starter时没有设定<code>&lt;version&gt;</code>标签则会依据通过父项目依赖来指定版本</li><li><strong>手动指定版本</strong>：<br>查看<code>spring-boot-dependencies</code>里设定版本用的标签；<br>在 pom.xml 中手动添加一个<code>&lt;properties&gt;</code>标签，在内部重写配置；<br>可以使用的版本号在<a href="https://mvnrepository.com/">MVNrepository</a>中查找；</li></ol><p>手动版本指定示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外：还可以在导入starter时，添加<code>&lt;version&gt;</code>标签来实现。</p><h2 id="2-自动配置与包结构"><a href="#2-自动配置与包结构" class="headerlink" title="2.自动配置与包结构"></a>2.自动配置与包结构</h2><p>这里简单记录SpringBoot为我们配置的项目以及包结构与扫描路径</p><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><ul><li>自动配好Tomcat<ul><li>引入Tomcat依赖</li><li>配置Tomcat</li></ul></li><li>自动配好SpringMVC<ul><li>引入SpringMVC全套组件</li><li>自动配好SpringMVC常用组件（功能）</li></ul></li><li>自动配好Web常见功能，如：字符编码问题<ul><li>SpringBoot帮我们配置好了所有web开发的常见场景</li></ul></li><li>各种配置拥有默认值<ul><li> 默认配置最终都是映射到某个类上，如：MultipartProperties</li><li> 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li></ul></li><li>按需加载所有自动配置项<ul><li>非常多的starter</li><li>引入了哪些场景这个场景的自动配置才会开启</li><li>SpringBoot所有的自动配置功能都在 <code>spring-boot-autoconfigure</code> 包里面</li></ul></li><li>自定配置包扫描</li></ul><h2 id="3-包结构与扫描路径"><a href="#3-包结构与扫描路径" class="headerlink" title="3.包结构与扫描路径"></a>3.包结构与扫描路径</h2><p>得益于Spring Boot的自动配置，我们也无需进行包扫描配置</p><ul><li>默认扫描：主程序所在包及其所有子包里的组件</li><li>改变扫描路径：<ul><li>法一：<code>@SpringBootApplication(scanBasePackages=&quot;扫描起始包名&quot;)</code></li><li>法二：<code>@ComponentScan</code>指定扫描路径（看代码块说明）</li></ul></li><li>正常情况需要把业务<code>@RestController</code>放在主程序包的子包里</li></ul><p><code>@ComponentScan</code>说明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">是一个复合注解，等同于</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(&quot;com.atguigu.boot&quot;)</span><br><span class="line">所谓的“法二”就是把这个复合注解展开写，然后改一下第三个标签</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2—HelloWord</title>
      <link href="/2021/10/02/SpringBoot2%E2%80%94HelloWord/"/>
      <url>/2021/10/02/SpringBoot2%E2%80%94HelloWord/</url>
      
        <content type="html"><![CDATA[<p>这是SpringBoot2的第一篇文章，以HelloWorld程序为例，讲述了SpringBoot2基本的Maven项目创建方式，以及常用注解的使用。</p><span id="more"></span><h2 id="创建Maven项目"><a href="#创建Maven项目" class="headerlink" title="创建Maven项目"></a>创建Maven项目</h2><p>正常的使用IDEA创建一个Maven项目即可。</p><h2 id="配置依赖-pom-xml"><a href="#配置依赖-pom-xml" class="headerlink" title="配置依赖(pom.xml)"></a>配置依赖(pom.xml)</h2><p>这里需要配置SpringBoot依赖，一定要添加父项目做依赖管理：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为这次的HelloWorld实例需求是一个web应用场景，所以需要引入<code>spring-boot-starter-web</code>这一官方启动器。<br>※关于启动器的详细内容请看「SpringBoot2——依赖管理、starter导入与包结构」</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建主程序-SpringBootApplication"><a href="#创建主程序-SpringBootApplication" class="headerlink" title="创建主程序(@SpringBootApplication)"></a>创建主程序(@SpringBootApplication)</h2><p>接下来要创建主程序，执行测试的时候，就直接运行主程序即可。创建时<strong>建议为主程序建立一个包</strong>，包名推荐<code>com.xxx.xxx.boot</code><br>主程序<strong>类上</strong>需要使用<code>@SpringBootApplication</code>注解来标记。<br>其作用是：表明这是一个SpringBoot应用，以及，指定组件扫描起始包<br>※关于包扫描参见「SpringBoot2——依赖管理、starter导入与包结构」</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span>：这是一个SpringBoot应用，组件从此包开始扫描</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写业务-Controller"><a href="#编写业务-Controller" class="headerlink" title="编写业务(@Controller)"></a>编写业务(@Controller)</h2><p>编写业务建议在<strong>主程序的子包中完成</strong>，创建包名推荐<code>com.xxx.xxx.boot.controller</code><br>业务<strong>类上</strong>需要用<code>@Controller</code>注解。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以不写 <span class="doctag">@Controller</span> 和 <span class="doctag">@ResponseBody</span> 然后在类上写 <span class="doctag">@RestController</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ResponseBody</span> 可以和 <span class="doctag">@Controller</span> 一同写在类上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot 2!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了如下注解<br>|注解|说明|<br>|:-:|:-:|<br>|@Controller|标记这是一个业务类|<br>|@ResponseBody|返回【字符串】给浏览器<br/>可以标记在类上，也可以标在方法上|<br>|@RestController|是@Controller和@ResponseBody的复合&lt;br&gt;标在类上|<br>|@RequestMapping(“/hello”)|映射http请求，请求内容为括号内内容|</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>直接运行main方法</p><h2 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h2><p>在<code>resources</code>目录下，创建<code>application.properties</code>文件，在里面写配置可以覆盖SpringBoot原有的默认配置。<br>比如修改tomcat端口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8888</span><br></pre></td></tr></table></figure><h2 id="简化部署"><a href="#简化部署" class="headerlink" title="简化部署"></a>简化部署</h2><p>在 pom.xml 中添加如下内容，然后点击左边Maven工具栏，选中<code>clean</code>和<code>package</code>即可自动部署成<code>jar</code>包，直接在目标服务器执行即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>※如果<code>spring-boot-maven-plugin</code>报错“不存在”，请手动加入<code>&lt;version&gt;</code>表情，版本和<code>&lt;parent&gt;</code>中的版本一致<br>※运行过程如有中断：取消掉cmd的快速编辑模式</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web编程 </tag>
            
            <tag> 固定写法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—File类与递归</title>
      <link href="/2021/09/28/Java%E5%9F%BA%E7%A1%80%E2%80%94File%E7%B1%BB%E4%B8%8E%E9%80%92%E5%BD%92/"/>
      <url>/2021/09/28/Java%E5%9F%BA%E7%A1%80%E2%80%94File%E7%B1%BB%E4%B8%8E%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>此部分记录了File类与递归的使用作为IO流部分的铺垫</p><p>File类的部分主要涉及「File类的创建、判断、获取路径与文件名、删除」等的操作</p><p>递归部分主要包括递归的含义以及使用「递归实现遍历目录」</p><span id="more"></span><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="File类概述与构造方法"><a href="#File类概述与构造方法" class="headerlink" title="File类概述与构造方法"></a>File类概述与构造方法</h3><p><strong>概述</strong></p><ul><li>它是文件和目录路径名的抽象表示</li><li>文件和目录是可以通过File封装成对象的</li><li>具体文件可存在也可不存在</li></ul><p><strong>构造函数</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">File(String pathname)</td><td align="center">给定的路径名字符串转换为抽象路径名 创建新的 File实例</td></tr><tr><td align="center">File(String parent, String child)</td><td align="center">从父路径名字符串+子路径名字符串 创建新的 File实例</td></tr><tr><td align="center">File(File parent, String child)</td><td align="center">从父抽象路径名+子路径名字符串 创建新的 File实例</td></tr></tbody></table><p><strong>绝对路径 与 相对路径</strong></p><ul><li>绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如：E:\itcast\java.txt</li><li>相对路径：必须使用取自其他路径名的信息进行解释。例如：myFile\java.txt</li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//File(String pathname)：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。</span></span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\railm\\Downloads\\Aliyun_Download\\Java笔记\\二阶day8资料\\素材\\itcast\\java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//File(String parent, String child)：从父路径名字符串和子路径名字符串创建新的 File实例。</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\railm\\Downloads\\Aliyun_Download\\Java笔记\\二阶day8资料\\素材\\itcast&quot;</span>, <span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//File(File parent, String child)：从父抽象路径名和子路径名字符串创建新的 File实例。</span></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">&quot;File(File parent, String child)：从父抽象路径名和子路径名字符串创建新的 File实例。&quot;</span>);</span><br><span class="line">        File f4 = <span class="keyword">new</span> File(<span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f4);</span><br></pre></td></tr></table></figure><h3 id="File类的创建功能"><a href="#File类的创建功能" class="headerlink" title="File类的创建功能"></a>File类的创建功能</h3><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public boolean createNewFile()</td><td align="center">该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</td></tr><tr><td align="center">public boolean mkdir()</td><td align="center">创建由此抽象路径名命名的目录</td></tr><tr><td align="center">public boolean mkdirs()</td><td align="center">创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录</td></tr></tbody></table><p>※如果有<strong>同名</strong>的“文件夹”会造成文件创建失败</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求1：我要在E:\\itcast目录下创建一个文件java.txt</span></span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\java.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.createNewFile());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求2：我要在E:\\itcast目录下创建一个目录JavaSE</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\JavaSE&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求3：我要在E:\\itcast目录下创建一个多级目录JavaWEB\\HTML</span></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\JavaWEB\\HTML&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdirs());</span><br></pre></td></tr></table></figure><h3 id="File类判断和获取功能"><a href="#File类判断和获取功能" class="headerlink" title="File类判断和获取功能"></a>File类判断和获取功能</h3><p><strong>判断功能方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public boolean isDirectory()</td><td align="center">测试此抽象路径名表示的File是否为目录</td></tr><tr><td align="center">public boolean isFile()</td><td align="center">测试此抽象路径名表示的File是否为文件</td></tr><tr><td align="center">public boolean exists()</td><td align="center">测试此抽象路径名表示的File是否存在</td></tr></tbody></table><p><strong>获取功能方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public String getAbsolutePath()</td><td align="center">返回此抽象路径名的绝对路径名字符串</td></tr><tr><td align="center">public String getPath()</td><td align="center">将此抽象路径名转换为路径名字符串</td></tr><tr><td align="center">public String getName()</td><td align="center">返回由此抽象路径名表示的文件或目录的名称</td></tr><tr><td align="center">public String[] list()</td><td align="center">返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</td></tr><tr><td align="center">public File[] listFiles()</td><td align="center">返回此抽象路径名表示的目录中的文件和目录的File对象数组</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\java.txt&quot;</span>);  <span class="comment">//使用 myFile 指向当前文件目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        public boolean isDirectory()：测试此抽象路径名表示的File是否为目录</span></span><br><span class="line"><span class="comment">//        public boolean isFile()：测试此抽象路径名表示的File是否为文件</span></span><br><span class="line"><span class="comment">//        public boolean exists()：测试此抽象路径名表示的File是否存在</span></span><br><span class="line">        System.out.println(f.isDirectory());</span><br><span class="line">        System.out.println(f.isFile());</span><br><span class="line">        System.out.println(f.exists());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串</span></span><br><span class="line"><span class="comment">//        public String getPath()：将此抽象路径名转换为路径名字符串</span></span><br><span class="line"><span class="comment">//        public String getName()：返回由此抽象路径名表示的文件或目录的名称</span></span><br><span class="line">        System.out.println(f.getAbsoluteFile());</span><br><span class="line">        System.out.println(f.getPath());</span><br><span class="line">        System.out.println(f.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        public String[] list()：返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</span></span><br><span class="line"><span class="comment">//        public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组</span></span><br><span class="line"><span class="comment">//        --数组需要遍历哦--</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast&quot;</span>);</span><br><span class="line">        String[] s = f2.list();</span><br><span class="line">        <span class="keyword">for</span>(String st : s)&#123;</span><br><span class="line">            System.out.println(st);</span><br><span class="line">        &#125;</span><br><span class="line">        File[] ft = f2.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File file : ft)&#123;</span><br><span class="line">            System.out.println(file);<span class="comment">//打印路径</span></span><br><span class="line">            System.out.println(file.getName());<span class="comment">//和 f2.list() 结果一致，给出文件名</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//意义:取出所有文件名,规避目录</span></span><br><span class="line">            <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                System.out.println(file.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="File类删除功能"><a href="#File类删除功能" class="headerlink" title="File类删除功能"></a>File类删除功能</h3><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public boolean delete()</td><td align="center">删除由此抽象路径名表示的文件或目录</td></tr></tbody></table><p>※对于删除文件夹，如果里面有文件，需要先删除文件</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\java.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//目录下创建java.txt</span></span><br><span class="line">        System.out.println(f1.createNewFile());</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line">        <span class="comment">//创建文件夹</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\itcast2&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line">        <span class="comment">//删除文件夹</span></span><br><span class="line">        System.out.println(f2.delete());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 目录套文件 */</span></span><br><span class="line">        <span class="comment">//创建目录并创建文件</span></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\itcast3&quot;</span>);</span><br><span class="line">        f3.mkdir();</span><br><span class="line">        File f4 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\itcast\\itcast3\\java.txt&quot;</span>);</span><br><span class="line">        f4.createNewFile();</span><br><span class="line">        <span class="comment">//创建文件之前应该创建目录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除itcast目录(目录内有内容),需要先删除内容</span></span><br><span class="line">        System.out.println(f4.delete());</span><br><span class="line">        System.out.println(f3.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="递归概述"><a href="#递归概述" class="headerlink" title="递归概述"></a>递归概述</h3><p>递归式是方法自己调用自己</p><p><strong>注意事项</strong></p><ul><li>递归一定要有出口，否则内存溢出</li><li>递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出</li></ul><h3 id="递归遍历目录"><a href="#递归遍历目录" class="headerlink" title="递归遍历目录"></a>递归遍历目录</h3><p><strong>思路</strong></p><ol><li>根据给定的路径创建一个File对象</li><li>定义一个方法，用于获取给定目录下的所有内容，参数为第1步创建的File对象</li><li>获取给定的File目录下所有的文件或者目录的File数组</li><li>遍历该File数组，得到每一个File对象</li><li>判断该File对象是否是目录<br>是：递归调用<br>不是：获取绝对路径输出在控制台</li><li>调用方法</li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\railm\\Downloads\\Aliyun_Download\\Java笔记\\二阶day8资料\\素材\\itcast&quot;</span>);</span><br><span class="line">        getAllFilePath(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFilePath</span><span class="params">(File f)</span></span>&#123;</span><br><span class="line">        File[] fileArray = f.listFiles();</span><br><span class="line">        <span class="comment">//保证文件健壮性，做个非空判断</span></span><br><span class="line">        <span class="keyword">if</span>(fileArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File file : fileArray) &#123;</span><br><span class="line"><span class="comment">//                判断该File对象是否是目录</span></span><br><span class="line"><span class="comment">//                是：递归调用</span></span><br><span class="line"><span class="comment">//                不是：获取绝对路径输出在控制台</span></span><br><span class="line">                <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                    getAllFilePath(file);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(file.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—类加载器与反射</title>
      <link href="/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>本文共分为类加载器和反射两个主题的内容。</p><p>类加载部分讲述了类加载的步骤、JVM类加载机制与加载器等理论性内容。</p><p>反射部分讲述了反射的基本使用，共分为「反射的概述、反射获取类与成员并使用、通过“外部文件”利用“反射”使用不同类和方法」三个部分。</p><span id="more"></span><h1 id="类加载器部分"><a href="#类加载器部分" class="headerlink" title="类加载器部分"></a>类加载器部分</h1><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><ul><li>就是指将class文件读入内存，并为之创建一个 java.lang.Class 对象</li><li>任何类被使用时，系统都会为之建立一个 java.lang.Class 对象<h3 id="类的连接"><a href="#类的连接" class="headerlink" title="类的连接"></a>类的连接</h3></li><li>验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致</li><li>准备阶段：负责为类的类变量分配内存，并设置默认初始化值</li><li>解析阶段：将类的二进制数据中的符号引用替换为直接引用<h3 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h3></li><li>在该阶段，主要就是对类变量进行初始化</li></ul><h3 id="类的初始化步骤"><a href="#类的初始化步骤" class="headerlink" title="类的初始化步骤"></a>类的初始化步骤</h3><ul><li>假如类还未被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还未被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li><li>*※注意**：在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3</li></ul><h3 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h3><ul><li>创建类的实例</li><li>调用类的类方法</li><li>访问类或者接口的类变量，或者为该类变量赋值</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li><li>初始化某个类的子类</li><li>直接使用java.exe命令来运行某个主类</li></ul><h2 id="JVM的类加载机制"><a href="#JVM的类加载机制" class="headerlink" title="JVM的类加载机制"></a>JVM的类加载机制</h2><ul><li>全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入<br>即：【如无指定<strong>全由这个加载器来加载</strong>】</li><li>父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类<br>即：【<strong>先有父类加载，加不了换自己</strong>】<br>缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区</li></ul><h2 id="Java中的内置类加载器"><a href="#Java中的内置类加载器" class="headerlink" title="Java中的内置类加载器"></a>Java中的内置类加载器</h2><ul><li>Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为<strong>null</strong> ，并且没有父null</li><li><strong>Platform</strong> class loader：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先定义的JavaSE平台API，其实现类和JDK特定的运行时类</li><li>System class loader：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类。</li></ul><p><strong>类加载器的继承关系</strong>：System的父加载器为Platform，而Platform的父加载器为Bootstrap</p><h2 id="ClassLoader的方法"><a href="#ClassLoader的方法" class="headerlink" title="ClassLoader的方法"></a>ClassLoader的方法</h2><ul><li>static ClassLoader getSystemClassLoader() 返回用于委派的系统类加载器</li><li>ClassLoader getParent()  返回父类加载器进行委派</li></ul><h1 id="反射部分"><a href="#反射部分" class="headerlink" title="反射部分"></a>反射部分</h1><h2 id="反射的概述【理解】"><a href="#反射的概述【理解】" class="headerlink" title="反射的概述【理解】"></a>反射的概述【理解】</h2><p>是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。<br>由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展</p><h2 id="反射获取类与成员并使用"><a href="#反射获取类与成员并使用" class="headerlink" title="反射获取类与成员并使用"></a>反射获取类与成员并使用</h2><h3 id="获取Class类对象（三种）"><a href="#获取Class类对象（三种）" class="headerlink" title="获取Class类对象（三种）"></a>获取Class类对象（三种）</h3><p><strong>方法</strong></p><ol><li>【最方便】使用类的class属性来获取该类对应的Class对象。举例：Student.class将会返回Student类对应的Class对象（常<strong>用在传入Construtor的传参</strong>）</li><li>调用对象的getClass()方法，返回该对象所属类对应的Class对象。该方法是Object类中的方法，所有的Java对象都可以调用该方法</li><li>【可由配置文件导入参数】使用Class类中的静态方法forName(String className)，该方法需要传入字符串参数，该字符串参数的值是某个类的全路径，也就是完整包名的路径</li></ol><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//1:使用类的class属性来获取该类对应的Class对象。举例：Student.class将会返回Student类对应的Class对象</span><br><span class="line">        Class&lt;Student&gt; c1 = Student.class;</span><br><span class="line">        System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        Class&lt;Student&gt; c2 = Student.class;</span><br><span class="line">        System.out.println(c1 == c2);//true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2:调用对象的getClass()方法，返回该对象所属类对应的Class对象</span><br><span class="line">//该方法是Object类中的方法，所有的Java对象都可以调用该方法</span><br><span class="line">        Student s = new Student();</span><br><span class="line">        Class&lt;? extends Student&gt; c3 = s.getClass();</span><br><span class="line">        System.out.println(c1 == c3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//3:使用Class类中的静态方法forName(String className)，该方法需要传入字符串参数，该字符串参数的值是某个类的全路径，也就是完整包名的路径</span><br><span class="line">        Class&lt;?&gt; c4 = Class.forName(&quot;com.itheima_02.Student&quot;);</span><br><span class="line">        System.out.println(c1 == c4);</span><br></pre></td></tr></table></figure><h3 id="反射获取【构造方法】并使用"><a href="#反射获取【构造方法】并使用" class="headerlink" title="反射获取【构造方法】并使用"></a>反射获取【构造方法】并使用</h3><p><strong>Class类中用于获取【构造方法】的方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Constructor&lt;?&gt;[] getConstructors()</td><td align="center">返回所有<strong>公共</strong>构造方法对象的【数组】</td></tr><tr><td align="center">Constructor&lt;?&gt;[] getDeclaredConstructors()</td><td align="center">返回所有构造方法对象的【数组】</td></tr><tr><td align="center">Constructor getConstructor(Class&lt;?&gt;… parameterTypes)</td><td align="center">返回单个<strong>公共</strong>构造方法对象</td></tr><tr><td align="center">Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td align="center">返回单个构造方法对象</td></tr></tbody></table><p><strong>Constructor类中用于创建对象的方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">T    newInstance(Object… initargs)</td><td align="center">使用此 构造器对象表示的构造方法，使用指定的初始化参数创建和初始化构造函数声明类的新实例</td></tr></tbody></table><p><strong>※暴力反射</strong>：当使用私有构造方法创建对象时，需要取消访问检查，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line"><span class="comment">//获取class对象</span></span><br><span class="line">        Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造方法(对象数组)：</span></span><br><span class="line">        <span class="comment">// 【法一：公共构造方法】Constructor&lt;?&gt;[] getConstructors() ———— 返回一个包含和 Constructor 对象数组，反映了该对象所有公共的构造函数</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons = c.getConstructors();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【法二：所有构造方法】Constructor&lt;?&gt;[] getDeclaredConstructors() ———— 返回 构造器对象的数组， 构造器对象反映由此 类对象表示的类声明的所有构造函数。</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons2 = c.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor con :cons2)&#123;</span><br><span class="line">            System.out.println(con);<span class="comment">//返回所有构造方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造方法(单个对象)：</span></span><br><span class="line">        <span class="comment">//【法一：指定公共构造函数】构造器&lt;T&gt;getConstructor​(类&lt;?&gt;... parameterTypes) ———— 返回一个 构造器对象，该对象反映此 类对象所表示的类的指定公共构造函数。</span></span><br><span class="line">        <span class="comment">//【法二：指定构造函数】构造器&lt;T&gt;getDeclaredConstructor​(类&lt;?&gt;... parameterTypes) ———— 返回一个 构造器对象，该对象反映此 类对象所表示的类或接口的指定构造函数。</span></span><br><span class="line">        <span class="comment">//参数：你要获得的构造方法的参数个数和数据类型的字节码对象</span></span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//利用反射创建对象</span></span><br><span class="line">        <span class="comment">//构造器提供有关类的单个构造函数的信息和访问权限。 ———— TnewInstance​(Object... initargs)   使用此 构造器对象表示的构造方法，使用指定的初始化参数创建和初始化构造函数声明类的新实例。</span></span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取【成员变量】并使用"><a href="#反射获取【成员变量】并使用" class="headerlink" title="反射获取【成员变量】并使用"></a>反射获取【成员变量】并使用</h3><p><strong>Class类中获取成员变量的方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Field[] getFields()</td><td align="center">返回所有公共成员变量对象的数组</td></tr><tr><td align="center">Field[] getDeclaredFields()</td><td align="center">返回所有成员变量对象的数组</td></tr><tr><td align="center">Field getField(String name)</td><td align="center">返回单个公共成员变量对象</td></tr><tr><td align="center">Field getDeclaredField(String name)</td><td align="center">返回单个成员变量对象</td></tr></tbody></table><p><strong>Field中用于给成员变量赋值的方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void    set (Object obj, Object value)</td><td align="center">将指定对象参数上此 字段对象表示的字段设置为指定的新值</td></tr></tbody></table><p><strong>※暴力反射</strong>：当使用私有成员变量创建时，需要取消访问检查，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; c = Class.forName(<span class="string">&quot;com.itheima_02.Student&quot;</span>);</span><br><span class="line"><span class="comment">//创建【成员函数(Field 字段)】反射对象</span></span><br><span class="line">        <span class="comment">//FieldgetField (String name) ———— 返回 字段对象，该对象反映此 类对象表示的类或接口的指定公共成员字段。</span></span><br><span class="line">        <span class="comment">//Field[]getFields() ———— 返回一个包含 字段对象的数组， 字段对象反映此 类对象所表示的类或接口的所有可访问公共字段。</span></span><br><span class="line">        <span class="comment">//FieldgetDeclaredField (String name) ———— 返回 字段对象，该对象反映此 类对象表示的类或接口的指定声明字段。</span></span><br><span class="line">        <span class="comment">//Field[]getDeclaredFields() ———— 返回 字段对象的数组， 字段对象反映由此 类对象表示的类或接口声明的所有字段。</span></span><br><span class="line"></span><br><span class="line">        Field[] fields = c.getFields();</span><br><span class="line">        Field[] declaredFields = c.getDeclaredFields();</span><br><span class="line">        Field addressField = c.getField(<span class="string">&quot;address&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用【成员变量(Field 字段)】</span></span><br><span class="line">        <span class="comment">//获取无参构造方法反射</span></span><br><span class="line">        Constructor&lt;?&gt; con = c.getConstructor();</span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用【成员方法】</span></span><br><span class="line">        <span class="comment">//voidset (Object obj, Object value) ———— 将指定对象参数上此 字段对象表示的字段设置为指定的新值。</span></span><br><span class="line">        addressField.set(obj,<span class="string">&quot;HK&quot;</span>);<span class="comment">//给obj的成员变量addressField赋值为”HK“</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取【成员方法】并使用"><a href="#反射获取【成员方法】并使用" class="headerlink" title="反射获取【成员方法】并使用"></a>反射获取【成员方法】并使用</h3><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Method[] getMethods()</td><td align="center">返回所有公共成员方法对象的数组，包括继承的</td></tr><tr><td align="center">Method[] getDeclaredMethods()</td><td align="center">返回所有成员方法对象的数组，不包括继承的</td></tr><tr><td align="center">Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td align="center">返回单个公共成员方法对象</td></tr><tr><td align="center">Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td align="center">返回单个成员方法对象</td></tr></tbody></table><p><strong>使用</strong><br>| 方法名 | 说明 |<br>| :—-: | :—-: |<br>Object invoke(Object obj,Object… args) |调用obj对象的成员方法，参数是args,返回值是Object类型</p><p><strong>※暴力反射</strong>：当使用私有成员方法时，需要取消访问检查，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="通过“外部文件”利用“反射”使用不同类和方法"><a href="#通过“外部文件”利用“反射”使用不同类和方法" class="headerlink" title="通过“外部文件”利用“反射”使用不同类和方法"></a>通过“外部文件”利用“反射”使用不同类和方法</h2><p>外部文件需要通过IO流的特殊操作流<code>Properties</code>来实现读取成为STring ，以便进行反射操作</p><p>~~~java<br>public class ReflectTest02 {<br>    public static void main(String[] args) throws ClassNotFoundException, IOException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {</p><pre><code>    /* *    此时外部文件的格式：    ***********    * class.txt    * className=xxx    * methodName=xxx    ***********    * */        //加载数据 - 利用”特殊操作流“    Properties prop = new Properties();    FileReader fr = new FileReader(&quot;myReflect\\class.txt&quot;);    prop.load(fr);    fr.close();    /*这样就拿到文件内数据了*/    String className = prop.getProperty(&quot;className&quot;);    String methodName = prop.getProperty(&quot;methodName&quot;);    //通过反射使用    Class&lt;?&gt; c = Class.forName(className);    Constructor&lt;?&gt; con = c.getConstructor();    Object obj = con.newInstance();    Method m = c.getMethod(methodName);    m.invoke(obj);&#125;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
            <tag> 类加载器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—Stream流</title>
      <link href="/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94Stream%E6%B5%81/"/>
      <url>/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>此部分记录了使用Java进行流式编程的思想与使用方法，共分为「Stream流思想、Stream流的使用、Stream流的收集操作」三个基础部分。因为流的中间操作方法较多，所以另外提供了一个流操作的综合实例。</p><span id="more"></span><h2 id="Stream流思想"><a href="#Stream流思想" class="headerlink" title="Stream流思想"></a>Stream流思想</h2><p>Stream流的操作一般分为三个流程：生成流 、中间操作、终结操作</p><p><img src="01.png" alt="图片"></p><h2 id="Stream流的使用"><a href="#Stream流的使用" class="headerlink" title="Stream流的使用"></a>Stream流的使用</h2><h3 id="Stream流的生成"><a href="#Stream流的生成" class="headerlink" title="Stream流的生成"></a>Stream流的生成</h3><p><strong>方法</strong></p><p>Stream流可以直接生成Collection体系集合以及数组，对于Map体系的集合，需要把Map转成Set集合</p><table><thead><tr><th align="center">数据类型</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td align="center">Collection体系集合</td><td>default Stream stream()</td><td>默认方法stream()生成流</td></tr><tr><td align="center">数组</td><td>static of(T… Values)</td><td>静态方法生成数组流</td></tr><tr><td align="center">Map体系</td><td>需要使用 keySet() values() entryStream() <br />来将Map体系转为Set集合，再利用 stream() 转为流</td><td>间接生成</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//Collection体系的集合可以使用默认方法stream ()生成流</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; listStream = list.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; setStream = set.stream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Map体系的集合【间接】的生成流</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">        Stream&lt;Integer&gt; valueStream = map.values().stream();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//数组可以通过Stream接口的静态方法of (T... values)生成流</span></span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; strArrayStream = Stream.of(strArray);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String流的中间操作"><a href="#String流的中间操作" class="headerlink" title="String流的中间操作"></a>String流的中间操作</h2><p><strong>方法</strong></p><p>这里方法较多，可以参考文档使用</p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Stream filter(Predicate predicate)</td><td align="center">用于对流中的数据进行过滤</td></tr><tr><td align="center">Stream limit(long maxSize)</td><td align="center">返回此流中的元素组成的流，截取前指定参数个数的数据</td></tr><tr><td align="center">Stream skip(long n)</td><td align="center">跳过指定参数个数的数据，返回由该流的剩余元素组成的流</td></tr><tr><td align="center">static Stream concat(Stream a, Stream b)</td><td align="center">合并a和b两个流为一个流</td></tr><tr><td align="center">Stream distinct()</td><td align="center">返回由该流的不同元素（根据Object.equals(Object) ）组成的流</td></tr><tr><td align="center">Stream sorted()</td><td align="center">返回由此流的元素组成的流，根据自然顺序排序</td></tr><tr><td align="center">Stream sorted(Comparator comparator)</td><td align="center">返回由该流的元素组成的流，根据提供的Comparator进行排序</td></tr><tr><td align="center">Stream map(Function mapper)</td><td align="center">返回由给定函数应用于此流的元素的结果组成的流</td></tr><tr><td align="center">IntStream mapToInt(ToIntFunction mapper)</td><td align="center">返回一个IntStream其中包含将给定函数应用于此流的元素的结果</td></tr></tbody></table><h3 id="Stream流的终结操作"><a href="#Stream流的终结操作" class="headerlink" title="Stream流的终结操作"></a>Stream流的终结操作</h3><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void forEach(Consumer action)</td><td align="center">对此流的每个元素执行操作</td></tr><tr><td align="center">long count()</td><td align="center">返回此流中的元素数</td></tr></tbody></table><h2 id="流的收集操作——工具类Collectors"><a href="#流的收集操作——工具类Collectors" class="headerlink" title="流的收集操作——工具类Collectors"></a>流的收集操作——工具类Collectors</h2><p><strong>作用</strong></p><p>把流收集成为“List”“Set”“Map”等集合</p><p>需要使用 <code>collect(Collectors.×××)</code> 其中括号里的 Collectors 是一个工具类</p><p><strong>Collectors方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public static Collectors toList()</td><td align="center">把元素收集到List集合中</td></tr><tr><td align="center">public static Collectors toSet()</td><td align="center">把元素收集到Set集合中</td></tr><tr><td align="center">public static Collectors toMap(Function keyMapper,Function valueMapper)</td><td align="center">把元素收集到Map集合中</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建List集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求1：得到名字为3个字的流</span></span><br><span class="line">        Stream&lt;String&gt; listStream = list.stream().filter(s -&gt; s.length() == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求2：把使用Stream流操作完毕的数据收集到List集合中并遍历</span></span><br><span class="line">        List&lt;String&gt; names = listStream.collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">for</span>(String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Set集合对象</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">20</span>);</span><br><span class="line">        set.add(<span class="number">30</span>);</span><br><span class="line">        set.add(<span class="number">33</span>);</span><br><span class="line">        set.add(<span class="number">35</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求3：得到年龄大于25的流</span></span><br><span class="line">        Stream&lt;Integer&gt; setStream = set.stream().filter(age -&gt; age &gt; <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求4：把使用Stream流操作完毕的数据收集到Set集合中并遍历</span></span><br><span class="line">        Set&lt;Integer&gt; ages = setStream.collect(Collectors.toSet());</span><br><span class="line">        <span class="keyword">for</span>(Integer age : ages) &#123;</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成</span></span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;王祖贤,33&quot;</span>, <span class="string">&quot;柳岩,25&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求5：得到字符串中年龄数据大于28的流</span></span><br><span class="line">        Stream&lt;String&gt; arrayStream = Stream.of(strArray).filter(s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求6：把使用Stream流操作完毕的数据收集到Map集合中并遍历，字符串中的姓名作键，年龄作值</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = arrayStream.collect(Collectors.toMap(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>], s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])));</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;,&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流的综合使用实例"><a href="#流的综合使用实例" class="headerlink" title="流的综合使用实例"></a>流的综合使用实例</h2><p><strong>实例要求</strong></p><p>现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作：</p><ol><li>男演员只要名字为3个字的前三人</li><li>女演员只要姓林的，并且不要第一个</li><li>把过滤后的男演员姓名和女演员姓名合并到一起</li><li>把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法</li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        ArrayList&lt;String&gt; manList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        manList.add(<span class="string">&quot;周润发&quot;</span>);</span><br><span class="line">        manList.add(<span class="string">&quot;成龙&quot;</span>);</span><br><span class="line">        manList.add(<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        manList.add(<span class="string">&quot;吴京&quot;</span>);</span><br><span class="line">        manList.add(<span class="string">&quot;周星驰&quot;</span>);</span><br><span class="line">        manList.add(<span class="string">&quot;李连杰&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; womanList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        womanList.add(<span class="string">&quot;林心如&quot;</span>);</span><br><span class="line">        womanList.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        womanList.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        womanList.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        womanList.add(<span class="string">&quot;林志玲&quot;</span>);</span><br><span class="line">        womanList.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; manStream = manList.stream();</span><br><span class="line">        Stream&lt;String&gt; womanStream = womanList.stream();</span><br><span class="line">        Stream.concat(manStream.filter(s -&gt; s.length() == <span class="number">3</span>).limit(<span class="number">3</span>), womanStream.filter(s -&gt; s.startsWith(<span class="string">&quot;林&quot;</span>)).skip(<span class="number">1</span>)).map(Actor::<span class="keyword">new</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>※字符串开头字符判断方法：<code>s.startsWith(&quot;x&quot;)</code></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—函数式接口</title>
      <link href="/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要记录了Java函数式接口的使用方法以及常用的函数式接口，函数式接口(Functional Interface)是Java 8对一类特殊类型的接口的称呼。 这类接口只定义了唯一的抽象方法的接口（除了隐含的Object对象的公共方法）。函数是接口是因为Lambda表达式必须要依赖于上下文存在，故此类接口是Lambda表达式（包括方法引用）的一种实现方式。</p><p>文章结构分为「函数式接口的概述、函数是接口的使用方式、常用的函数式接口」三个部分。</p><span id="more"></span><h2 id="函数式接口的概述"><a href="#函数式接口的概述" class="headerlink" title="函数式接口的概述"></a>函数式接口的概述</h2><p><strong>概念</strong></p><ul><li>有且仅有一个抽象方法的接口，即可以使用Lambda表达式的接口</li><li>函数式接口可以用作【参数传递】&amp;【局部变量】</li></ul><p><strong>函数式接口标记</strong><br><code>@FunctionalInterface</code>(建议加上)</p><p>放在接口定义的上方：如果接口是函数式接口，编译通过；如果不是，编译失败</p><h2 id="函数式接口的使用方式"><a href="#函数式接口的使用方式" class="headerlink" title="函数式接口的使用方式"></a>函数式接口的使用方式</h2><h3 id="函数式接口作为方法的参数-以Runnable-为例"><a href="#函数式接口作为方法的参数-以Runnable-为例" class="headerlink" title="函数式接口作为方法的参数(以Runnable()为例)"></a>函数式接口作为方法的参数(以Runnable()为例)</h3><p><strong>要求</strong><br>定义一个类(RunnableDemo)，在类中提供两个方法：</p><p>一个方法是：startThread(Runnable r) 方法参数Runnable是一个函数式接口</p><p>一个方法是：主方法，在主方法中调用startThread方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在主方法中调用startThread方法</span></span><br><span class="line">        <span class="comment">//匿名内部类的方式</span></span><br><span class="line">        startThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程 - 匿名内部类的方式&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//Lambda表达式的方式</span></span><br><span class="line">        startThread(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程 - Lambda表达式的方式&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line"><span class="comment">//        Thread t = new Thread(r);</span></span><br><span class="line"><span class="comment">//        t.start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数式接口作为方法的返回值-以Comparator-为例"><a href="#函数式接口作为方法的返回值-以Comparator-为例" class="headerlink" title="函数式接口作为方法的返回值(以Comparator() 为例)"></a>函数式接口作为方法的返回值(以Comparator() 为例)</h3><p><strong>要求</strong></p><p>定义一个类(ComparatorDemo)，在类中提供两个方法：</p><p>一个方法是：Comparator getComparator() 方法返回值Comparator是一个函数式接口</p><p>一个方法是主方法，在主方法中调用getComparator方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造使用场景</span></span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        array.add(<span class="string">&quot;abcdefghijklmn&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;199&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前&quot;</span> + array);</span><br><span class="line"></span><br><span class="line">        Collections.sort(array, getComparator());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序后&quot;</span> + array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">getComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名内部类实现</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s1.length() - s2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda表达式方式</span></span><br><span class="line">        <span class="keyword">return</span> (s1, s2) -&gt; s1.length() - s2.length(); <span class="comment">//函数式接口作为方法的返回值，使用Lambda接口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用的函数式接口"><a href="#常用的函数式接口" class="headerlink" title="常用的函数式接口"></a>常用的函数式接口</h2><h3 id="生产型接口——Supplier"><a href="#生产型接口——Supplier" class="headerlink" title="生产型接口——Supplier"></a>生产型接口——Supplier</h3><p><strong>作用</strong></p><p>如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据供我们使用。</p><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">T get()</td><td align="center">按照某种实现逻辑(由Lambda表达式实现)返回一个数据</td></tr></tbody></table><p><strong>示例</strong></p><p><strong>案例需求</strong><br>定义一个类(SupplierTest)，在类中提供两个方法</p><p>​    一个方法是：int getMax(Supplier sup) 用于返回一个int数组中的最大值</p><p>​    一个方法是主方法，在主方法中调用getMax方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxValue = getMax(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">                max = Math.max(max, arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 SupPlier&lt;T&gt; 的 get() 方法返回一个最大值，具体实现由主类中的Lambda实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费型接口——Consumer"><a href="#消费型接口——Consumer" class="headerlink" title="消费型接口——Consumer"></a>消费型接口——Consumer</h3><p><strong>作用</strong></p><p>对传入参数执行或依次执行操作，它消费的数据的数据类型由泛型指定</p><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void accept(T t)</td><td align="center">对给定的参数执行此操作</td></tr><tr><td align="center">default Consumer andThen(Consumer after)</td><td align="center">返回一个组合的Consumer，依次执行此操作，然后执行after操作<br />采用链式编程</td></tr></tbody></table><p><strong>示例</strong></p><p><strong>案例需求</strong><br>String[] strArray = {“林青霞,30”, “张曼玉,35”, “王祖贤,33”};</p><p>字符串数组中有多条信息，请按照格式：“姓名：XX,年龄：XX”的格式将信息打印出来</p><p><strong>要求</strong><br>把打印姓名的动作作为第一个Consumer接口的Lambda实例</p><p>把打印年龄的动作作为第二个Consumer接口的Lambda实例</p><p>将两个Consumer接口按照顺序组合到一起使用</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;小林,30&quot;</span>, <span class="string">&quot;小张,35&quot;</span>, <span class="string">&quot;小王,33&quot;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//con1 与 con2 的操作在此处定义</span></span><br><span class="line">        printNameAge(strArray, s -&gt; System.out.print(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>]), (s -&gt; System.out.println(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNameAge</span><span class="params">(String[] strArray, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String s : strArray)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对传入参数 s ，先进行 con1 的操作；再进行 con2 的操作。</span></span><br><span class="line">            <span class="comment">//con1 与 con2 的操作由主类Lambda表达式定义</span></span><br><span class="line">            con1.andThen(con2).accept(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断用接口——Predicate"><a href="#判断用接口——Predicate" class="headerlink" title="判断用接口——Predicate"></a>判断用接口——Predicate</h3><p><strong>作用</strong></p><p>Predicate接口通常用于判断参数是否满足指定的条件</p><p><strong>方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">boolean test(T t)</td><td align="center">对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回一个布尔值</td></tr><tr><td align="center">default Predicate negate()</td><td align="center">返回一个逻辑的否定，对应逻辑非</td></tr><tr><td align="center">default Predicate and(Predicate other)</td><td align="center">返回一个组合判断，对应短路与</td></tr><tr><td align="center">default Predicate or(Predicate other)</td><td align="center">返回一个组合判断，对应短路或</td></tr></tbody></table><p><strong>示例</strong></p><ul><li><p>练习描述</p><ul><li><p>String[] strArray = {“林青霞,30”, “柳岩,34”, “张曼玉,35”, “貂蝉,31”, “王祖贤,33”};</p></li><li><p>字符串数组中有多条信息，请通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中，并遍历ArrayList集合</p></li><li><p>同时满足如下要求：</p><p>姓名长度大于2；年龄大于33</p></li></ul></li><li><p>分析</p><ul><li>有两个判断条件,所以需要使用两个Predicate接口,对条件进行判断</li><li>必须同时满足两个条件,所以可以使用and方法连接两个判断条件</li></ul></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;柳岩,34&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;貂蝉,31&quot;</span>, <span class="string">&quot;王祖贤,33&quot;</span>&#125;;</span><br><span class="line">        ArrayList&lt;String&gt; array = myFilter(strArray, s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length() &gt; <span class="number">2</span>, s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">33</span>);</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">myFilter</span><span class="params">(String[] strArray, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s : strArray)&#123;</span><br><span class="line">            <span class="comment">//这里是对 s 判断一下 pre2 和 pre1 的真假，然后进行与操作</span></span><br><span class="line">            <span class="comment">//至于 pre1 和 pre2 的判断过程，由主流的Lambda表达式给出</span></span><br><span class="line">            <span class="keyword">if</span>(pre1.and(pre2).test(s))&#123;</span><br><span class="line">                array.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据处理返回用接口——Function"><a href="#数据处理返回用接口——Function" class="headerlink" title="数据处理返回用接口——Function"></a>数据处理返回用接口——Function</h3><p><strong>作用</strong></p><p>Function&lt;T,R&gt;接口通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值。转换前的数据类型是 T ，转换后的数据类型是 R 。</p><p><strong>方法</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>R apply(T t)</td><td>将此函数应用于给定的参数</td></tr><tr><td>default Function andThen(Function after)</td><td>返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果</td></tr></tbody></table><p><strong>示例</strong></p><ul><li>练习描述<ul><li>String s = “林青霞,30”;<br>请按照我指定的要求进行操作：</li><li>1:将字符串截取得到数字年龄部分<br>2:将上一步的年龄字符串转换成为int类型的数据<br>3:将上一步的int数据加70，得到一个int结果，在控制台输出</li><li>请通过Function接口来实现函数拼接</li></ul></li><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;林青霞,30&quot;</span>;</span><br><span class="line">        Integer converted = convert(s, s1 -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]), s2 -&gt; s2 + <span class="number">70</span>);</span><br><span class="line">        System.out.println(converted);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">convert</span><span class="params">(String s, Function&lt;String, Integer&gt; fun1, Function&lt;Integer, Integer&gt; fun2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回处理结果，对 s 先进行 fun1 的运算，再进行 fun2 的运算</span></span><br><span class="line">        <span class="keyword">return</span> fun1.andThen(fun2).apply(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda表达式 </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—接口的组成更新</title>
      <link href="/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E6%88%90%E6%9B%B4%E6%96%B0/"/>
      <url>/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E6%88%90%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要记录了Java中接口的不同方法，Java随着版本更新提供了更多的接口方法，这些方法的出现使得接口中不再只能有抽象方法与常量，增加了程序的可维护性。</p><p>文章结构分为「接口组成更新的概述、接口的默认方法、接口的静态方法、接口的私有方法」四个部分。</p><span id="more"></span><h2 id="接口组成更新的概述"><a href="#接口组成更新的概述" class="headerlink" title="接口组成更新的概述"></a>接口组成更新的概述</h2><ul><li>常量 public static final</li><li>抽象方法 public abstract</li><li>默认方法(Java 8)</li><li>静态方法(Java 8)</li><li>私有方法(Java 9)</li></ul><h2 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h2><p><strong>格式</strong><br>public default 返回值类型 方法名(参数列表) {<strong>方法体</strong>}<br>※public可以省略<br><strong>注意</strong><br>默认方法不是抽象方法，实现类<strong>不强制重写</strong>，<strong>也可以重写</strong>，public 可以省略<br><strong>作用</strong><br>维护接口，增加功能<br><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的静态方法"><a href="#接口的静态方法" class="headerlink" title="接口的静态方法"></a>接口的静态方法</h2><p><strong>格式</strong><br>public static 返回值类型 方法名(参数列表) { }<br>※public可以省略<br><strong>注意</strong><br>只能通过<strong>接口名调用</strong><br><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接口内：</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show3-静态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">测试类：</span><br><span class="line">            Inter.show3();</span><br></pre></td></tr></table></figure><h2 id="接口的私有方法"><a href="#接口的私有方法" class="headerlink" title="接口的私有方法"></a>接口的私有方法</h2><p><strong>产生背景</strong><br>【静态方法】 与 【默认方法】给接口引入“方法体”，所以需要将“方法体内相同内容抽出来”，故必然会产生【私有方法】<br><strong>格式</strong></p><ul><li><strong>格式1</strong>：接口私有方法<br><code>private 返回值类型 方法名(参数列表) &#123; &#125;</code><br><strong>范例1</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>格式2</strong>：接口私有静态方法<br><code>private static 返回值类 方法名(参数列表) &#123; &#125;</code><br><strong>范例2</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>私有静态方法：能用到【接口静态方法】【接口默认方法】</li><li>私有方法：只能用【接口默认方法】</li></ul><p><strong>综合示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接口默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show2开始执行&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//接口默认方法接受【接口私有方法】、【接口私有静态方法】</span></span><br><span class="line">        show();</span><br><span class="line">        method();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;show2结束执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接口静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2开始执行&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//接口静态方法只接受【接口私有静态方法】</span></span><br><span class="line">        method();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;method2结束执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//接口私有方法(上面调用)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初级工程师&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中级工程师&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;高级工程师&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//接口私有静态方法(上面调用)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初级工程师&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中级工程师&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;高级工程师&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—Lambda表达式与方法引用</title>
      <link href="/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
      <url>/2021/09/27/Java%E5%9F%BA%E7%A1%80%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要记录了Java中Lambda表达式的使用方式和方法引用。Lambda表达式是函数式编程思想的体现，函数式编程思想尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”。Lambda表达式遵循“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导。</p><p>方法引用是Lambda的孪生兄弟，与Lambda表达式同样可以根据上下文进行推导，使用方法引用可以减少代码复杂度。</p><p>文章结构分为「Lambda表达式的格式与使用、Lambda表达式与匿名内部类的区别、方法引用概述、Lambda表达式支持的方法引用」四个部分。</p><span id="more"></span><h2 id="Lambda表达式的格式与使用"><a href="#Lambda表达式的格式与使用" class="headerlink" title="Lambda表达式的格式与使用"></a>Lambda表达式的格式与使用</h2><p><strong>使用前提</strong></p><ul><li>必须要有<strong>接口</strong>，接口只有<strong>一个</strong>抽象方法</li><li>必须有<strong>上下文环境</strong>才能推到Lambda对应的接口</li></ul><h3 id="Lambda表达式的标准格式"><a href="#Lambda表达式的标准格式" class="headerlink" title="Lambda表达式的标准格式"></a>Lambda表达式的标准格式</h3><p><strong>格式</strong><br>标准格式由三要素组成：<strong>形式参数</strong>、<strong>箭头</strong>、<strong>代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(形式参数) -&gt; &#123;代码块(具体要做的事情)&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p><strong>示例要求</strong>：计算<code>x + y</code>，使用有参有返回的抽象方法</p><p><strong>代码实现：</strong></p><p>接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Addable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        useAddable((<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useAddable</span><span class="params">(Addable a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = a.add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p><code>useAddable(Addable a)</code>需要传入一个<code>Addable接口</code>的实现类。传入后，<code>useAddable(Addable a)</code>方法就可以调用<code>Addable接口</code>中的<code>a.add(int x, int y)</code>的方法。所以主类中我们就传入了一个Labmda表达式，相当于重写了接口类的<code> add(int x,int y)</code>方法。</p><p>此处也可以使用匿名内部类重写<code>a.add(int x, int y)</code>来实现，但较为麻烦，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useAddable(<span class="keyword">new</span> Addable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> x + y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式的缩略形式"><a href="#Lambda表达式的缩略形式" class="headerlink" title="Lambda表达式的缩略形式"></a>Lambda表达式的缩略形式</h3><p><strong>格式</strong></p><p>Lambda表达式可以有条件的缩略，具体缩略情况如下：</p><ol><li>省略参数类型</li><li>省略小括号：参数只有一个</li><li>省略大括号和分号，以及return：如果只有一条语句</li></ol><p><strong>示例</strong></p><p>用缩略写法表示上一个示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useAddable((x, y) -&gt; x + y);</span><br></pre></td></tr></table></figure><h2 id="Lambda表达式和匿名内部类的区别"><a href="#Lambda表达式和匿名内部类的区别" class="headerlink" title="Lambda表达式和匿名内部类的区别"></a>Lambda表达式和匿名内部类的区别</h2><ul><li>所需类型不同<ul><li>匿名内部类：可以是接口，也可以是抽象类，还可以是具体类</li><li>Lambda表达式：只能是接口</li></ul></li><li>使用限制不同<ul><li>如果接口抽象方法<strong>1个</strong>：都可以</li><li>如果接口抽象方法<strong>多个</strong>：<strong>匿名内部类</strong>only</li></ul></li><li>实现原理不同<ul><li>匿名内部类：编译之后，产生一个单独的.class字节码文件</li><li>Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成</li></ul></li></ul><h2 id="方法引用概述"><a href="#方法引用概述" class="headerlink" title="方法引用概述"></a>方法引用概述</h2><p><strong>方法引用符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::</span><br></pre></td></tr></table></figure><p><strong>推导与省略</strong></p><ul><li>如果使用Lambda，那么根据“可推导就是可省略”的原则，<strong>无需指定参数类型</strong>，<strong>也无需指定的重载形式</strong>，它们都将被自动推导</li><li>如果使用方法引用，也是同样可以根据上下文进行推导</li><li>方法引用是<strong>Lambda的孪生兄弟</strong></li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        usePrintable(System.out::println);<span class="comment">//方法引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usePrintable</span><span class="params">(Printable p)</span></span>&#123;</span><br><span class="line">        p.printInt(<span class="number">46</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda表达式支持的方法引用"><a href="#Lambda表达式支持的方法引用" class="headerlink" title="Lambda表达式支持的方法引用"></a>Lambda表达式支持的方法引用</h2><p>支持如下方法的方法引用：</p><ul><li>引用类方法</li><li>引用对象实例方法</li><li>引用类的实例方法</li><li>引用构造器</li></ul><h3 id="引用类方法"><a href="#引用类方法" class="headerlink" title="引用类方法"></a>引用类方法</h3><p><strong>格式</strong>：</p><p><code>类名::静态方法</code><br><strong>范例</strong>：</p><p><code>Integer::parseInt</code></p><p>其调用的方法是：<code>public static int parseInt(String s)</code></p><p><strong>示例</strong></p><p>练习：</p><ol><li>定义一个接口(Converter)，里面定义一个抽象方法：int convert(String s);</li><li>定义一个测试类(ConverterDemo)，在测试类中提供两个方法<br>一个方法是：useConverter(Converter c)<br>一个方法是主方法，在主方法中调用useConverter方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConverterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        useConverter((String s) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            return Integer.parseInt(s);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        useConverter(Integer::parseInt);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//Lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useConverter</span><span class="params">(Converter c)</span></span>&#123;</span><br><span class="line">        c.convert(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用对象实例方法"><a href="#引用对象实例方法" class="headerlink" title="引用对象实例方法"></a>引用对象实例方法</h3><p><strong>格式</strong></p><p><code>对象::成员方法</code></p><p><strong>范例</strong></p><p><code>&quot;HelloWorld&quot;::toUpperCase String</code></p><p>类中的方法：public String toUpperCase() 将此String所有字符转换为大写</p><p><strong>传参</strong></p><p>Lambda表达式被对象的实例方法替代的时候，它的<strong>形式参数全部传递</strong>给该方法作为参数</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintString ps = <span class="keyword">new</span> PrintString();<span class="comment">//类</span></span><br><span class="line">        usePrinter(ps::printUpper);<span class="comment">//的实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usePrinter</span><span class="params">(Printer p)</span></span>&#123;</span><br><span class="line">        p.printUpperCase(<span class="string">&quot;hfd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用类的实例放法"><a href="#引用类的实例放法" class="headerlink" title="引用类的实例放法"></a>引用类的实例放法</h3><p>引用类的实例方法，其实就是引用类中的成员方法</p><p><strong>格式</strong></p><p><code>类名::成员方法</code></p><p><strong>范例</strong></p><p><code>String::substring</code></p><p>使用的<code>public String substring(int beginIndex,int endIndex)</code></p><p>（从beginIndex开始到endIndex结束，截取字符串。返回一个子串，子串的长度为endIndex-beginIndex）</p><p><strong>传参</strong></p><p>Lambda表达式被类的实例方法替代的时候，<strong>第一个参数作为调用者</strong>，<strong>后面的参数全部传递给该方法作为参数</strong>。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Lambda</span></span><br><span class="line">        useMyString((String s, <span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; s.substring(x, y));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//引用类的实例方法</span></span><br><span class="line">        useMyString(String::substring);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式被类的实例方法替代的时候</span></span><br><span class="line">        <span class="comment">//第一个参数作为调用者</span></span><br><span class="line">        <span class="comment">//后面的参数全部传递给该方法作为参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useMyString</span><span class="params">(MyString my)</span></span>&#123;</span><br><span class="line">        System.out.println(my.mySubString(<span class="string">&quot;abcdefg&quot;</span>, <span class="number">2</span>, <span class="number">5</span>));;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用构造器（构造方法）"><a href="#引用构造器（构造方法）" class="headerlink" title="引用构造器（构造方法）"></a>引用构造器（构造方法）</h3><p><strong>格式</strong> ：</p><p><code>类名::new</code><br><strong>范例</strong> ：</p><p><code>Student::new</code></p><p><strong>传参</strong></p><p>Lambda表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数</p><p><strong>示例</strong><br>练习</p><ol><li><p>定义一个类(Student)，里面有两个成员变量(name,age) 并提供无参构造方法和带参构造方法，以及成员变量对应的get和set方法</p></li><li><p>定义一个接口(StudentBuilder)，里面定义一个抽象方法**<code>Student build(String name,int age);</code>**</p></li><li><p>定义一个测试类(StudentDemo)，在测试类中提供两个方法</p><p>一个方法是：useStudentBuilder(StudentBuilder s)</p><p>一个方法是主方法，在主方法中调用useStudentBuilder方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式标准写法：</span></span><br><span class="line"><span class="comment">//        useStudentBuilder((String name, int age) -&gt; &#123;</span></span><br><span class="line"><span class="comment">////            Student s = new Student(name, age);</span></span><br><span class="line"><span class="comment">////            return s;</span></span><br><span class="line"><span class="comment">//            return new Student(name, age);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        useStudentBuilder((String name, <span class="keyword">int</span> age) -&gt; <span class="keyword">new</span> Student(name, age));<span class="comment">//Lambda表达式缩略</span></span><br><span class="line"></span><br><span class="line">        useStudentBuilder(Student::<span class="keyword">new</span>);<span class="comment">//引用构造器方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useStudentBuilder</span><span class="params">(StudentBuilder sb)</span></span>&#123;</span><br><span class="line">        Student s = sb.build(<span class="string">&quot;王守义&quot;</span>, <span class="number">13</span>);</span><br><span class="line">        System.out.println(s.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda表达式 </tag>
            
            <tag> 函数式式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—网络编程</title>
      <link href="/2021/09/25/Java%E5%9F%BA%E7%A1%80%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/09/25/Java%E5%9F%BA%E7%A1%80%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>此部分记录了使用Java进行网络编程所使用的基本类与方法，共分为「InetAddress类、UDP通信、TCP通信」三个基础部分，并通过两个实例展示「自定键盘输入、字符缓冲流封装、反馈、从文件到文件的发送接收」展示IO流与网络编程结合的拓展使用方法。</p><span id="more"></span><h2 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h2><p>此类的主要作用是产生主机的对象，拥有如下方法：</p><p>使用时，通常不会单独用构造函数创建一个对象，而是直接使用这个静态函数当作参数</p><table><thead><tr><th align="center">方法名</th><th>类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">static InetAddress.getByName(String host)</td><td>构造函数</td><td align="center">确定主机名称的IP地址。<br />host 可以是机器名称，也可以是IP地址</td></tr><tr><td align="center">String getHostName()</td><td>方法</td><td align="center">获取此IP地址的主机名</td></tr><tr><td align="center">String getHostAddress()</td><td>方法</td><td align="center">返回文本显示中的IP地址字符串</td></tr></tbody></table><h2 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h2><p><strong>概念</strong></p><ul><li>它在通信的两端各建立一个Socket对象，没有所谓的客户端和服务器</li><li>Java提供了DatagramSocket类作为基于UDP协议的Socket</li></ul><h3 id="UDP发送数据"><a href="#UDP发送数据" class="headerlink" title="UDP发送数据"></a>UDP发送数据</h3><p><strong>构造方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DatagramSocket()</td><td align="center">创建【数据报套接字】，并将其绑定到本机地址上的任何可用端口</td></tr><tr><td align="center">DatagramPacket(byte[] buf,int len,InetAddress add,int port)</td><td align="center">创建【数据包】,发送长度为len的数据包到指定主机的指定端口</td></tr></tbody></table><p><strong>相关方法</strong></p><table><thead><tr><th align="center">对应类</th><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DatagramSocket</td><td align="center">void send(DatagramPacket p)</td><td align="center">发送数据报包</td></tr><tr><td align="center">DatagramSocket</td><td align="center">void close()</td><td align="center">关闭数据报套接字</td></tr></tbody></table><p><strong>表格描述</strong></p><p>操作中需要两个对象：</p><ul><li>发送端对象(<code>DatagramSocket</code>)：负责提供发送的方法</li><li>数据包对象(<code>DatagramPacket</code>)：负责指定数据包「内容、接收端主机对象、端口」</li></ul><table><thead><tr><th align="center">操作位置</th><th align="center">操作方式</th><th align="center">方法名/类名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">主类</td><td align="center">new</td><td align="center">DatagramSocket()</td><td align="center">创建发送端的Socket对象</td></tr><tr><td align="center">—</td><td align="center">定义</td><td align="center">byte[] bys = “xxx”.getBytes();</td><td align="center">创建数据</td></tr><tr><td align="center">—</td><td align="center">new</td><td align="center">DatagramPacket(byte[] buf,int len,InetAddress add,int port)</td><td align="center">数据打包</td></tr><tr><td align="center">—</td><td align="center">调用</td><td align="center">void send(DatagramPacket p)</td><td align="center">调用DatagramSocket对象方法发送数据</td></tr><tr><td align="center">—</td><td align="center">调用</td><td align="center">ds.close();</td><td align="center">关闭接收端</td></tr></tbody></table><p><strong>代码描述</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">    DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据，并把数据打包</span></span><br><span class="line">    <span class="keyword">byte</span>[] bys = <span class="string">&quot;Udp 示例&quot;</span>.getBytes();</span><br><span class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length, InetAddress.getByName(<span class="string">&quot;192.168.1.3&quot;</span>), <span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用DatagramSocket对象的方法发送数据</span></span><br><span class="line">    ds.send(dp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭发送端</span></span><br><span class="line">    ds.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="UDP接收数据"><a href="#UDP接收数据" class="headerlink" title="UDP接收数据"></a>UDP接收数据</h3><hr><p><strong>构造方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DatagramPacket(byte[] buf, int len)</td><td align="center">创建一个DatagramPacket用于接收长度为len的数据包</td></tr></tbody></table><p><strong>DatagramPacket相关方法</strong></p><table><thead><tr><th align="center">对应类</th><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DatagramPacket</td><td align="center">byte[] getData()</td><td align="center">返回数据缓冲区</td></tr><tr><td align="center">DatagramPacket</td><td align="center">int getLength()</td><td align="center">返回要发送的数据的长度或接收的数据的长度</td></tr><tr><td align="center">DatagramSocket</td><td align="center">void receive(DatagramPacket p)</td><td align="center">从此套接字接受数据报包给到<code>DatagramPacket</code></td></tr></tbody></table><p><strong>表格描述</strong></p><table><thead><tr><th align="center">操作位置</th><th align="center">操作方式</th><th align="center">方法名/类名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">主类</td><td align="center">new</td><td align="center">DatagramPacket(byte[] buf, int len)</td><td align="center">创建接收端的Socket对象</td></tr><tr><td align="center">—</td><td align="center">创建</td><td align="center">byte[] bys = new byte[1024];<br />DatagramPacket dp = new DatagramPacket(bys, bys.length);</td><td align="center">创建数据包，用于接收数据</td></tr><tr><td align="center">—</td><td align="center">调用</td><td align="center">ds.receive(dp);</td><td align="center">调用DatagramSocket对象的方法接收数据(上一节)</td></tr><tr><td align="center">—</td><td align="center">匿名内部类/new</td><td align="center">String new String(dp.getData(), 0,dp.getLength())</td><td align="center">解析数据</td></tr><tr><td align="center">—</td><td align="center">调用</td><td align="center">ds.close();</td><td align="center">关闭接收端</td></tr></tbody></table><p><strong>代码描述</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个【数据包】，用于接收数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">        ds.receive(dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------啰嗦写法-----------</span></span><br><span class="line">        <span class="comment">//解析【数据包】，取出【数据包】中的字节数组并把数据在控制台显示</span></span><br><span class="line">        <span class="keyword">byte</span>[] datas = dp.getData();<span class="comment">//创建一个字节数组用于接收【数据包】内的字节数组</span></span><br><span class="line">        <span class="comment">//获取实际发送数据的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = dp.getLength();</span><br><span class="line">        <span class="comment">//开始解析</span></span><br><span class="line">        String dataString = <span class="keyword">new</span> String(datas, <span class="number">0</span>, len);<span class="comment">//排除多余空字符</span></span><br><span class="line">        System.out.println(dataString);</span><br><span class="line">    <span class="comment">//---------------啰嗦写法 End-----------</span></span><br><span class="line">        <span class="comment">//简化写法：</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>,dp.getLength()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭接收端</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP通信程序"><a href="#TCP通信程序" class="headerlink" title="TCP通信程序"></a>TCP通信程序</h2><p><strong>Java中的TCP通信</strong></p><ul><li>Java使用Socket对象代表两端的通信端口，并通过<strong>Socket产生IO流</strong>来通信。</li><li>Java为客户端提供了Socket类，为服务器端提供了ServerSocket类</li></ul><h3 id="TCP发送数据"><a href="#TCP发送数据" class="headerlink" title="TCP发送数据"></a>TCP发送数据</h3><p><strong>表格描述</strong></p><table><thead><tr><th align="center">操作位置</th><th align="center">操作方式</th><th align="center">方法名/类名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">主类</td><td align="center">new</td><td align="center">Socket(String host, int port)</td><td align="center">创建客户端Socket对象</td></tr><tr><td align="center">—</td><td align="center">调用Socket方法</td><td align="center">OutputStream getOutputStream()</td><td align="center">获取输出流…</td></tr><tr><td align="center">—</td><td align="center">调用OutputStream方法</td><td align="center">void write(“TCP 示例”.getBytes())</td><td align="center">…写数据</td></tr><tr><td align="center">—</td><td align="center">调用Socket方法</td><td align="center">void close()</td><td align="center">释放资源</td></tr></tbody></table><p>※释放资源只要释放最顶层的对象，衍生的对象也会释放</p><p><strong>代码描述</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建客户端的Socket对象(Socket)</span></span><br><span class="line">        <span class="comment">//Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号</span></span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10088</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取输出流，写数据</span></span><br><span class="line">        <span class="comment">//OutputStream getOutputStream() 返回此套接字的输出流</span></span><br><span class="line">        OutputStream os = s.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;hello,tcp！！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP接收数据"><a href="#TCP接收数据" class="headerlink" title="TCP接收数据"></a>TCP接收数据</h3><p><strong>表格描述</strong></p><table><thead><tr><th align="center">操作位置</th><th align="center">操作方式</th><th align="center">方法名/类名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">主类</td><td align="center">new</td><td align="center">ServerSocket(int port)</td><td align="center">创建服务器端的Socket对象(ServerSocket)</td></tr><tr><td align="center">—</td><td align="center">调用ServerSocket方法</td><td align="center">Socket accept()</td><td align="center">侦听连接到此的套接字<br />接收成为【socket】对象</td></tr><tr><td align="center">—</td><td align="center">调用Socket方法</td><td align="center">InputStream getInputStream()</td><td align="center">获取输入流…</td></tr><tr><td align="center">—</td><td align="center">调用InputStream方法</td><td align="center">byte[] bys = new byte[1024];<br />int len = is.read(bys)</td><td align="center">…读数据…</td></tr><tr><td align="center">—</td><td align="center">new/匿名内部类</td><td align="center">String new String(bys,0,len)</td><td align="center">…数据处理</td></tr><tr><td align="center">—</td><td align="center">调用Socket与ServerSocket方法</td><td align="center">close()</td><td align="center">释放资源</td></tr></tbody></table><p>※此处「字节流读数据」不能使用while循环</p><h2 id="拓展操作实例-以TCP为例"><a href="#拓展操作实例-以TCP为例" class="headerlink" title="拓展操作实例(以TCP为例)"></a>拓展操作实例(以TCP为例)</h2><h3 id="自定键盘输入-封装字符缓冲流-发送"><a href="#自定键盘输入-封装字符缓冲流-发送" class="headerlink" title="自定键盘输入+封装字符缓冲流 发送"></a>自定键盘输入+封装字符缓冲流 发送</h3><p><strong>案例需求</strong></p><p>客户端：数据来自于键盘录入，直到输入的数据是886,发送数据结束 </p><p>服务端：接收到数据在控制台输出</p><p><strong>案例分析</strong> </p><p>客户端创建对象，使用键盘录入循环接受数据，接受一行发送一行，直到键盘录入886为止</p><p>服务端创建对象，使用输入流按行循环接受数据，直到接受到null为止</p><p><strong>代码实现</strong></p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//手寫鍵盤輸入為字符輸出流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10086</span>);</span><br><span class="line">        <span class="comment">//通信的IO流封裝字節輸出流</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(line.equals(<span class="string">&quot;886&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10086</span>);</span><br><span class="line">        Socket s = ss.accept();</span><br><span class="line">        <span class="comment">//封裝字符輸入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件到文件-反馈-多线程"><a href="#文件到文件-反馈-多线程" class="headerlink" title="文件到文件+反馈+多线程"></a>文件到文件+反馈+多线程</h3><p><strong>案例需求</strong> </p><p>客户端：数据来自于文本文件，接收服务器反馈 </p><p>服务器：接收到的数据写入文本文件，给出反馈，代码用线程进行封装，为每一个客户端开启一个线程</p><p><strong>案例分析</strong></p><p>创建客户端对象，创建输入流对象指向文件，每读入一行数据就给服务器输出一行数据，输出结束后使 用shutdownOutput()方法告知服务端传输结束 </p><p>创建多线程类，在run()方法中读取客户端发送的数据，为了防止文件重名，使用计数器给文件名编号， 接受结束后使用输出流给客户端发送反馈信息。 </p><p>创建服务端对象，每监听到一个客户端则开启一个新的线程接受数据。 客户端接受服务端的回馈信息 </p><p><strong>代码实现</strong></p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//客户端对象+字符流</span></span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10090</span>);</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件输入流对象+发送文件</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;C:\\test\\ArrayListToFileDemo.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收反馈</span></span><br><span class="line">        BufferedReader receive = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">        String receiveLine = receive.readLine();</span><br><span class="line">        System.out.println(receiveLine);</span><br><span class="line"></span><br><span class="line">        s.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收传入的对象</span></span><br><span class="line">    <span class="keyword">private</span> Socket s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排除文件重名问题</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\test\\TCPTHREAD&quot;</span> + i + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (file.exists()) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\test\\TCPTHREAD&quot;</span> + i + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//追加写入</span></span><br><span class="line">                BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>));</span><br><span class="line">                bw.write(line);</span><br><span class="line">                bw.newLine();</span><br><span class="line">                bw.flush();</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反馈</span></span><br><span class="line">            BufferedWriter back = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line">            back.write(<span class="string">&quot;接收到文件&quot;</span> + i);</span><br><span class="line">            back.newLine();</span><br><span class="line">            back.flush();</span><br><span class="line"></span><br><span class="line">            s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建服务器Socket对象</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10090</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//美接收到一个 ss.accept() 就创建并开启线程</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerThread(ss.accept())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例说明</strong></p><ul><li>线程类中：不可以在排除文件重名时创建文件，否则会一直循环。如果要创建，需要利用if去break</li><li>线程类中：之所以使用追加写入，就是为了能释放资源</li><li>服务端类中：开启线程使用的是缩略写法</li><li>此实例中如果排除“多线程”的话写法如下，可以更清晰的感知服务端的写法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//标准服务端操作(SS对象+侦听+封装)</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10000</span>);</span><br><span class="line">        Socket s = ss.accept();</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件写入封装</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\test\\TCPWriterNoTwo.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反馈</span></span><br><span class="line">        BufferedWriter back = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line">        back.write(<span class="string">&quot;接收完成&quot;</span>);</span><br><span class="line">        back.newLine();</span><br><span class="line">        back.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ss.close();</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础—多线程</title>
      <link href="/2021/09/23/Java%E5%9F%BA%E7%A1%80%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/09/23/Java%E5%9F%BA%E7%A1%80%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要记录了Java中多线程的基础操作，文章结构分为「多线程的实现方法、多线程的基本操作、线程安全」三个部分以及一个「生产者与消费者模型」的实例。</p><span id="more"></span><h2 id="多线程的实现方法"><a href="#多线程的实现方法" class="headerlink" title="多线程的实现方法"></a>多线程的实现方法</h2><h3 id="方法一：继承Thread类"><a href="#方法一：继承Thread类" class="headerlink" title="方法一：继承Thread类"></a>方法一：继承Thread类</h3><p>需要：线程类 + 主类</p><p><strong>表格描述</strong></p><table><thead><tr><th align="center">操作位置</th><th align="center">操作方式</th><th align="center">方法名/类名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">线程类(MyThread)</td><td align="center">继承</td><td align="center">Thread</td><td align="center">定义一个类MyThread继承Thread类</td></tr><tr><td align="center">—</td><td align="center">重写</td><td align="center">void run()</td><td align="center">在MyThread类中重写run()方法</td></tr><tr><td align="center">主类</td><td align="center">new</td><td align="center">线程类</td><td align="center">创建MyThread类的对象</td></tr><tr><td align="center">—</td><td align="center">对象.方法</td><td align="center">void start()</td><td align="center">【启动线程】执行线程类重写的方法</td></tr></tbody></table><p><strong>代码描述</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyThread类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread my1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread my2 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 start() 方法启动线程，调 run() 方法</span></span><br><span class="line">        my1.start();</span><br><span class="line">        my2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：实现Runnable接口"><a href="#方法二：实现Runnable接口" class="headerlink" title="方法二：实现Runnable接口"></a>方法二：实现Runnable接口</h3><p>主要：线程类 + 主类</p><p><strong>表格描述</strong></p><table><thead><tr><th align="center">操作位置</th><th align="center">操作方式</th><th align="center">方法名/类名/接口名</th><th>传参</th><th align="center">说明</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">线程类(MyRunnable)</td><td align="center">实现</td><td align="center">Runnable</td><td></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">—</td><td align="center">重写</td><td align="center">void run()</td><td></td><td align="center"></td><td align="center">*需要获取<code>Thread.currentThread()</code>才能对类操作</td></tr><tr><td align="center">主类</td><td align="center">new</td><td align="center">线程类(MyRunnable)</td><td></td><td align="center">创建MyRunnable类的对象</td><td align="center"></td></tr><tr><td align="center">—</td><td align="center">new</td><td align="center">Thread类</td><td>线程类对象</td><td align="center">创建Thread类的对象，<br/>把MyRunnable对象作为构造方法的参数</td><td align="center">*多种构造方法</td></tr><tr><td align="center">—</td><td align="center">对象.方法</td><td align="center">void start()</td><td></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>Thread类构造方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Thread(Runnable target)</td><td align="center">分配一个新的Thread对象</td></tr><tr><td align="center">Thread(Runnable target, String name)</td><td align="center">分配一个新的Thread对象<br/>并给线程命名</td></tr></tbody></table><p><strong>代码描述</strong></p><p>MyRunnable类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i); <span class="comment">//要先获取当前线程类的引用【Thread.currentThread()】后才能用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyRunnable类的对象</span></span><br><span class="line">        MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Thread类的对象，把MyRunnable对象作为构造方法的参数</span></span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处</strong></p><ul><li>避免了Java单继承的局限性(Runnable 可以再继承其他类)</li><li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</li></ul><h2 id="对线程的操作"><a href="#对线程的操作" class="headerlink" title="对线程的操作"></a>对线程的操作</h2><p>主要包括：「获取/设置线程名称、线程调度、线程控制」以及特殊方法「获取当前线程对象的引用」</p><h3 id="A-获取当前线程对象的引用"><a href="#A-获取当前线程对象的引用" class="headerlink" title="A:获取当前线程对象的引用"></a>A:获取当前线程对象的引用</h3><p>因为对线程的操作需要对“Thread类的引用”操作。所以，在<strong>【Runnable类】</strong>和<strong>【主类】</strong>要对当前类操作时，需要用此方法</p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th><th>使用方法</th></tr></thead><tbody><tr><td align="center">Thread currentThread()</td><td align="center">返回对当前正在执行的线程对象的引用</td><td>Thread.currentThread().xxx</td></tr></tbody></table><p>例如：在<strong>【Runnable类】</strong>和<strong>【主类】</strong>中要获得线程名称，使用<code>Thread.currentThread().getName()</code></p><h3 id="B-设置-获取线程名称"><a href="#B-设置-获取线程名称" class="headerlink" title="B:设置/获取线程名称"></a>B:设置/获取线程名称</h3><p><strong>方法一：使用Thread类方法</strong></p><p>方法列表：</p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void setName(String name)</td><td align="center">【设置线程名字】为name</td></tr><tr><td align="center">String getName()</td><td align="center">【返回线程名称】</td></tr></tbody></table><p><strong>方法二：使用带参构造函数命名</strong></p><table><thead><tr><th>多线程实现方法</th><th>构造函数</th><th>使用示例</th></tr></thead><tbody><tr><td>继承Thread类</td><td>Thread(String name)</td><td>MyThread my = new MyThread(“小狗”);</td></tr><tr><td>实现Runnable方法</td><td>Thread(Runnable target, String name)</td><td>Thread th = new Thread(myRunnable, “小猫”);</td></tr></tbody></table><h3 id="C-线程调度"><a href="#C-线程调度" class="headerlink" title="C:线程调度"></a>C:线程调度</h3><p><strong>优先级</strong></p><p>主要靠优先级来实现，关于优先级有如下说明：</p><ul><li>默认优先级：Thread.NORM_PRIORTY     (=5)</li><li>优先级范围：Thread.MIN_PRIORTY    (=1) ~ Thread.MAX_PRIORITY    (=10)</li><li>线程优先级高代表获取线程优先级高，<em>不保证先运行</em></li></ul><p><strong>优先级操作方法：</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">final int getPriority()</td><td align="center">获取优先级</td><td align="center">tp1.getPriority()</td></tr><tr><td align="center">final void setPriority(int newPriority)</td><td align="center">设置优先级</td><td align="center">tp1.setPriority(5);</td></tr></tbody></table><h3 id="D-线程控制"><a href="#D-线程控制" class="headerlink" title="D:线程控制"></a>D:线程控制</h3><p><strong>控制方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">static void sleep(long millis)</td><td align="center">使线程停留指定的毫秒数</td><td align="center">Thread.sleep(1000);<br />*异常处理</td></tr><tr><td align="center">void join()</td><td align="center">等待此线程死亡后才能执行其他</td><td align="center">tj1.join();<br />*异常处理</td></tr><tr><td align="center">void setDaemon(boolean on)</td><td align="center">标记守护线程※</td><td align="center">td1.setDaemon(true);</td></tr></tbody></table><p><strong>控制意义</strong></p><ul><li><code>sleep()</code>：让这个线程停下来，给别的线程抢资源。让线程们大致均匀的抢资源</li><li><code>join()</code>：让这个线程死亡再执行其他，阻止其他线程抢资源</li><li><code>setDaemon(boolean on)</code>：如果只剩下守护线程，那么 <em>虚拟机就退出</em></li></ul><h2 id="线程安全——同步-synchronized"><a href="#线程安全——同步-synchronized" class="headerlink" title="线程安全——同步 synchronized"></a>线程安全——同步 synchronized</h2><p><strong>判断多线程是否会出现数据安全问题的标准</strong></p><ul><li>是否<strong>多线程</strong>环境</li><li>是否有<strong>共享数据</strong></li><li>是否有<strong>多条语句操作共享数据</strong>（含比较、更改、输出等各种操作）</li></ul><p><strong>关于锁</strong></p><p>锁是通过对象来判定的，对象是同一个，就是同一个锁，会同时锁住。</p><h3 id="A-同步代码块（给代码块加锁）"><a href="#A-同步代码块（给代码块加锁）" class="headerlink" title="A:同步代码块（给代码块加锁）"></a>A:同步代码块（给代码块加锁）</h3><p><strong>使用位置</strong></p><p>锁住“操作共享数据的多条语句”</p><p>只要同步代码块锁中传入的对象是同一个，就是同一个锁，会同时锁住</p><p><strong>使用格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();<span class="comment">//一定要在外界创建对象，一个对象就是一把锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(任意对象-obj)&#123;</span><br><span class="line">    多条语句操作共享数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-同步-成员-方法（给方法加锁）"><a href="#B-同步-成员-方法（给方法加锁）" class="headerlink" title="B:同步(成员)方法（给方法加锁）"></a>B:同步(成员)方法（给方法加锁）</h3><p><strong>使用格式</strong></p><p>分类同步方法和同步静态方法，区别就是是否有<code>static</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;<span class="keyword">static</span>&gt; <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">    多次操作的共享数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>锁的对象</strong></p><ul><li>非静态方法：<code>this</code></li><li>静态方法：<code>类名.class</code>（此方法在反射中，可以获得类）</li></ul><h3 id="C-线程安全的类【理解即可】"><a href="#C-线程安全的类【理解即可】" class="headerlink" title="C:线程安全的类【理解即可】"></a>C:线程安全的类【理解即可】</h3><h3 id="线程安全数据类型："><a href="#线程安全数据类型：" class="headerlink" title="线程安全数据类型："></a>线程安全数据类型：</h3><h4 id="StringBuffer（线程安全可变的字符序列）"><a href="#StringBuffer（线程安全可变的字符序列）" class="headerlink" title="StringBuffer（线程安全可变的字符序列）"></a>StringBuffer（线程安全可变的字符序列）</h4><ul><li>线程安全，可变的字符序列</li><li>从JDK 5开始，被StringBuilder 替代。 通常应该使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为它不执行同步</li></ul><h4 id="Vector（线程安全列表List）"><a href="#Vector（线程安全列表List）" class="headerlink" title="Vector（线程安全列表List）"></a>Vector（线程安全列表List）</h4><ul><li>从Java 2平台v1.2开始，<strong>该类改进了List接口</strong>，使其成为Java Collections Framework的成员。 与新的集合实现不同， Vector被同步。</li><li><strong>如果不需要线程安全的实现，建议使用ArrayList代替Vector</strong></li></ul><h4 id="Hashtable（线程安全Hash表）"><a href="#Hashtable（线程安全Hash表）" class="headerlink" title="Hashtable（线程安全Hash表）"></a>Hashtable（线程安全Hash表）</h4><ul><li>该类实现了一个哈希表，它将键映射到值。 任何非null对象都可以用作键或者值</li><li>从Java 2平台v1.2开始，该类进行了改进，<strong>实现了Map接口</strong>，使其成为Java Collections Framework的成员。 与新的集合实现不同， Hashtable被同步。</li><li><strong>如果不需要线程安全的实现，建议使用HashMap代替Hashtable</strong></li></ul><h3 id="使非线程安全的数据类型变成线程安全-Collections"><a href="#使非线程安全的数据类型变成线程安全-Collections" class="headerlink" title="使非线程安全的数据类型变成线程安全(Collections)"></a>使非线程安全的数据类型变成线程安全(Collections)</h3><ul><li>static List synchronizedList ( List list);</li><li>static List synchronizedSet ( Set list);</li><li>static List synchronizedMap ( Map list);</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br></pre></td></tr></table></figure><h2 id="线程安全——锁-Lock接口"><a href="#线程安全——锁-Lock接口" class="headerlink" title="线程安全——锁 Lock接口"></a>线程安全——锁 Lock接口</h2><p>使用方法请关注「代码描述」</p><p><strong>Lock说明</strong></p><ul><li>是接口，采用它的实现类ReentrantLock来实例化</li><li>比<code>synchronized</code>更广放的锁定操作</li><li>使用于线程类中</li><li>Lock 加锁解锁 要用 try{…}finally{…} 环绕，防止程序出错不能解锁</li></ul><p><strong>构造方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ReentrantLock()</td><td align="center">创建一个ReentrantLock的实例</td></tr></tbody></table><p><strong>加解锁方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void lock()</td><td align="center">加锁</td></tr><tr><td align="center">void unlock()</td><td align="center">解锁</td></tr></tbody></table><p>※Lock 加锁解锁 要用 try{…}finally{…} 环绕，防止程序出错不能解锁</p><p><strong>代码描述</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//利用 Lock 的实现类对象 创建 Lock：</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Lock 加锁解锁 要用 try&#123;...&#125;finally&#123;...&#125; 环绕，防止程序出错不能解锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//加锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><h3 id="模型概述"><a href="#模型概述" class="headerlink" title="模型概述"></a>模型概述</h3><p>是一个经典的多线程模型，提供<strong>两个线程</strong>和一个<strong>数据共享区</strong>。数据共享区的存在<strong>解耦</strong>了生产者和消费者关系。</p><p>此程序<strong>关键在于数据共享区提供的操作</strong></p><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">生产者线程</td><td align="center">生产数据</td></tr><tr><td align="center">消费者线程</td><td align="center">使用数据</td></tr><tr><td align="center">共享数据区域</td><td align="center">生产者产生的数据放入<strong>共享区域</strong>，不关心消费者使用<br />消费者从<strong>共享区域</strong>域获取数据，不关心数据生产</td></tr></tbody></table><p>示意图：</p><p><img src="file://C:/Users/railm/.config/joplin-desktop/resources/5ce77a07ee354d1383cab1b70ee76ed5.png?t=1631372335477" alt="img"></p><h3 id="等待与唤醒"><a href="#等待与唤醒" class="headerlink" title="等待与唤醒"></a>等待与唤醒</h3><p><strong>使用注意</strong></p><ul><li><code>wite()</code>与<code>notify()</code>方法，必须在同步(锁)内部使用；</li><li><code>wite()</code>之后必须要<code>notify()</code>唤醒方可继续执行;</li></ul><p><strong>方法</strong><br>来自 <code>Object类</code></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void wait()</td><td align="center">当前线程等待，直到另一个线程调用该对象唤醒（ notify()方法或notifyAll()方法）</td></tr><tr><td align="center">void notify()</td><td align="center">唤醒正在等待对象监视器的单个线程</td></tr><tr><td align="center">void notifyAll()</td><td align="center">唤醒正在等待对象监视器的所有线程</td></tr></tbody></table><h3 id="实例【生产者与消费者】"><a href="#实例【生产者与消费者】" class="headerlink" title="实例【生产者与消费者】"></a>实例【生产者与消费者】</h3><p><strong>实例指南</strong></p><p>生产者消费者案例中包含的类：</p><ol><li>奶箱类(Box)：定义一个成员变量，表示第x瓶奶，<strong>提供存储牛奶和获取牛奶的操作</strong></li><li>生产者类(Producer)：实现Runnable接口，重写run()方法，调用存储牛奶的操作</li><li>消费者类(Customer)：实现Runnable接口，重写run()方法，调用获取牛奶的操作</li><li>测试类(BoxDemo)：里面有main方法，main方法中的代码步骤如下<pre><code> A:创建奶箱对象，这是共享数据区域 B:创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作 C:创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作 D:创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递 E:启动线程</code></pre></li></ol><p><strong>代码实现</strong></p><p><strong>Box类（重点）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示第x瓶奶，提供存储牛奶和获取牛奶的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> milk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个成员变量，表示Box的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供存储牛奶和获取牛奶的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> milk)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果有奶，就等待消费</span></span><br><span class="line">        <span class="keyword">if</span>(state)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有牛奶，就生产牛奶</span></span><br><span class="line">        <span class="keyword">this</span>.milk = milk;</span><br><span class="line">        System.out.println(<span class="string">&quot;送奶工送入第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产完毕之后，修改Box状态，唤醒其他等待的线程</span></span><br><span class="line">        state = <span class="keyword">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果没奶，就等待生产</span></span><br><span class="line">        <span class="keyword">if</span>(!state)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有奶，就消费牛奶</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户拿到第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费牛奶之后，就修改Box状态,唤醒其他等待的线程</span></span><br><span class="line">        state = <span class="keyword">false</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Producer类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(Box b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">            b.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Customer类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Box b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            b.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建奶箱对象，这是共享数据区域</span></span><br><span class="line">        Box b = <span class="keyword">new</span> Box();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作</span></span><br><span class="line">        Producter producter = <span class="keyword">new</span> Producter(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</span></span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(producter);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(customer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
